compile.c (здесь и ниже всегда одна и та же копия) компилирует 151 секунду (no delays)
тогда все модули компилятора будут 151 с * 152k/48k = 478 секунд (07.04.2017 уже 132k)
оптимизировал поиск меток: теперь компилирует 44.86 секунд (no delays)
улучшил хэш-функцию: теперь компилирует 43.72 секунд (no delays)
почистил readchar: 42.68 - неточно, т.к. не обнулил FRAMES
убрал waseol: 42.08
оптимизировал сравнение в readcomment: 41.08
инлайн readcomment: 41.08 (т.е. нет выигрыша)
заменил на _tword[_FIRST] на *(PCHAR)_tword: 40.96
упростил логику после readcomment: 40.68
ещё упростил (убрал проверку _tword[_FIRST]==_DIERESIS): 40.66
убрал _docomment: 40.34
isnum по таблице: 40.18
isalpha по таблице: 39.86
isalphanum по таблице: 38.18
isalphanum инлайн в readconcattword: 37.56
ускорил strjoin: 36.02
strcopy через асмолибу: 35.5
strpush через strcopy: 34.88
strpop через strcopy: 33.86
убрал терминатор в strjoin: 33.74
заменил по возможности strjoin на strcopy: 32.44
в read инлайном strclose: 32.12
в compile инлайном strclose: 32.12 (т.е. нет выигрыша по скорости, только по размеру)
strjoin через асмолибу: 31.12, ещё ускорил (на 4 такта в цикле, теперь 67): 31.08/31.2
ещё ускорил (cpir + ldir): 31/31.08/31.02/31.1/31.16 (чем дольше numlock, тем больше время? нет, непредсказуемо на других компиляциях)
обход логики readcomment: 30.8
ещё ускорил isnum: 30.8
было
isnum.
	LD HL,_charflags.
	LD A,[isnum.c.]
	LD E,A
	LD D,0
	ADD HL,DE
	LD L,[HL]
	LD A,0x01
	SUB L
	LD L,0
	JR NZ,$+2+1
	DEC L
	LD A,L
	RET 
стало
isnum.
	LD A,[isnum.c.]
	LD E,'0'
	SUB E
	LD E,0x0a
	SUB E
	SBC A,A
	RET 
isnum инлайн: 30.78
убрал isalpha, а isalphanum через таблицу bool везде инлайн: 30.06
отсортировал проверки в cast: 29.68
отсортировал проверки в push,pop,сравнениях,убрал char и bool в сравнениях больше-меньше (исключил ошибку сравнения знаковых char): 30 (почему???)
отсортировал проверки в вызовах и лог.операциях, убрал char и int в лог.операциях: 30.06/29.86 (почему???)
сделал обход лишних операций в eat_cmd: 29.66
пробовал быстрый выход из eat_expr и т.п. по ')' - нет выигрыша (убрал)
переделал eat_expr и т.п. в процедуры: 29.68 (почему??)
отсортировал операции в eat_expr и т.п.: 29.62
в eat_expr и т.п. вместо && поставил if..if..if: 29.54
убрал лишнее сравнение в let: 29.4
в eat_sumval, eat_mulval убрал dbl и сделал if..if: 29.52 (почему??) (заодно убрал ^^)
ускорил проверку числового формата: 29.34
в readchar сделал if..if: 29.02
в readchar присваивание wasdieresis в разных местах: 28.64
в readchar присваивание wasescape в разных местах: 28.36
в readchar сделал сравнения на верхнем уровне по одному символу: 27.4
в readchar (rdch) быстрый выход: 26.18 (сильно увеличилась память под метки и вырос размер на 104 байта)
в rdch инлайн stradd: 25.22
убрал noskip: 25
исправил оптимизацию условия в eat_repeat: 24.66
упростил хэш-функцию: 23.68
поиск меток через strcp (асм), добавление меток через strcopy: 22.78
вернул _docomment: 22.84
убрал ld l,(hl): 22.84 (выигрыш только по размеру и меткам)
убрал _asms: 22.44
emit через writefout: 21.74
вернул shrb, shlb: 21.72
упростил fread, fwrite: 21.2
убрал дебажные проверки в regs: 21.6 (почему???)
ещё упростил fread: 21.4
ускорил сдвиг таблицы регистров в regs: 21.35
склеил emitpopreg + getoldestrg: 21.48 (почему???)
getrfree не функция, а процедура: 21.32
защита от зацикливания do_val в рекурсивных вызовах, а не в начале: 21.48 (почему???)
_t = _T_UNKNOWN в ошибке, а не в начале do_val, opsym в do_val глобальный: 21.3
убрал вложенность foutuint: 21.32 (почему???)
убрал <<1 в адресации по хэшу: 21.26
ускорил fputs: 20.88
в rdch пробел приоритетнее: 20.68
\ в rdch не проверяется, убрал wasescape: 20.58
в rdch убрал repeat..until: 20.2
добавил в либу strjoineol для joinwords: 19.68
exprlvl и namespclvl типа byte: 19.54
сделал читабельнее работу с указателями: 19.66 (почему???)
убрал lblbuflen и lblcount: 19.6
eat_expr и т.п. через repeat..until, а не while: 19.34
readconcattword через repeat..until, а не while: 19.62 (почему???)
в comments < вместо <=: 19.4
&_TYPEMASK вместо &~_T_CONST: 19.44 (почему???)
добавил extract (-e) в nedotrd: выходной асм соответствует тому, что на пц
убрал в LF проверку eof (rdch и readnocr) - добавляет лишнюю строчку в конце файла
убрал кавычки из rdch: 19.44 (почему???)
убрал docomment в readconcattword: 19.06
убрал \t в rdch: 18.98
сделал DIERESIS = ' ', убрал второй параметр в rdquotes: 19.18 (почему???)
убрал readbrackets: 19.28 (почему???)
stradd в асмолибе: 18.32
rdch вместо readnocr в одном месте readcomment: 18.06
rdch инлайн, с разделением "ждать нецифробукву" и "ждать недиерезис", eof даёт \n: 16.82
итого почти 100 строк в секунду (1590 строк utf8)


время readfin (bd75) = обычно 450 t (включая вызов) * 49870 b = 22441500 t = 6.4 с (пусть 7) - ускорил до обычно 95 t (включая вызов) * 49870 b = 4737650 t = 1.4 с (пусть 2)
время fwrite (62bf) = обычно 243 t (включая вызов) * 61452 b = 14932836 t = 4.3 с (пусть 5) - в большинстве случаев ускорено через writefout
итого время файловых операций незначительно
(но время сильно - на полсекунды - зависит от начального сектора свободного места на диске)
(рамдиск на полсекунды медленнее, чем перехват FDD в UnrealSpeccy - цифры по перехвату FDD)
 
токенизатор асма из экспортёра 52.98 с (надо ускорить сравнения строк - а) через хэш, б) разрешить команды только с табом и проверять пару символов (сделал так потом))
после того, как убрал _docomment: 53.26
обход логики readcomment: 53.3 (почему???)
isnum инлайн: 53.08
убрал isalpha, а isalphanum через таблицу bool везде инлайн: 52.58
проверка команд только при _asmspcsize!=0: 44.18
отсортировал проверку команд по частоте: 31.32
после всех оптимизаций read: 23.62
strcp в асмолибе (не используется в токенизаторе!) и ещё что-то (сократил экспортёр?): 22.4
вернул _docomment: 21.88
упростил fread, fwrite: 21.46
ещё упростил fread: 21.6 (почему???)
итого 160 строк в секунду (3523 строк)
asm.f из токенизатора (7832 строк): 44.1
итого 178 строк в секунду
добавил extract (-e) в nedotrd: выходной tok.f соответствует тому, что на пц
сделал отдельные версии read: 43.76
в токенизированном асме в текст комментария входит символ комментария, убрал
stradd и strcplow в асмолибе: 37.48
итого 209 строк в секунду
rdch инлайн, с разделением "ждать нецифробукву" и "ждать недиерезис", eof даёт \n: 29.94
28.76
токенизация всего компилятора:
47.74*3500000/12374 = 13500 t/строку
47.74*3500000/170214 = 980 t/символ (хотя в главном цикле чтения 324,352/270 t/символ)

время работы ассемблера на tok.f из экспортёра (55424 байта (3715 строк, 578 меток) против 203175 (13015 строк, 1645 меток) у компилятора): 33 секунды на 2 прохода
после оптимизации чтения и записи получилось 19.86 секунд (3640 строк)
улучшил хэш-функцию: 18.6 (когда было 18.5? увеличился объём экспортёра или были глюки в асме? сейчас 54709 байт, 3687 строк)
с новым экспортёром: 18.02 (3518 строк - почему видно 3523? потому что теряем комментарии ;;)
asmwordpopvalue через fwrite: 17.6
asmbytepopvalue через writefout: 17.94 (почему???)
_nvalues как byte: 17.7
инлайн asmpopvalue, без проверки: 17.44
исправил оптимизацию условия в eat_repeat: 16.82
упростил хэш-функцию: 15.82
поиск меток через strcp (асм): 14.74
добавление меток через strcopy: 14.24
вернул shrb, shlb: 14.46 (почему???)
заменил 0x70+(_reg>>0x03) на (_reg>>0x03)+0x70: 14.2
упростил findlabel: 14
упростил addlabel: 14
упростил fread, fwrite: 13.96
ещё упростил fread: 13.8
на первом проходе не открываем ferr и не пишем туда: 12.1
на первом проходе вообще ничего не пишем: 12.06
итого 292 строк в секунду (3523 строк)
tok.f из токенизатора (7842 строк): 38.02
tok.f из асма (5751 строк): 36.64
убрал лишнее присваивание в поиске меток: 36.58
быстрое чтение byte и uint из массива long: 36.26
итого 160 строк в секунду (5790 строк, 1065 меток) - почему??? (там много длинных меток с #)
ускорил #: 36.52 (почему???) 35.98
34.60 (5366 строк)
итого 206 строк в секунду - почему??? слишком много меток?

экспорт на tok.f из экспортёра: 15.2
через writestr: 7.38
упростил fread, fwrite: 7.12
итого 500 строк в секунду (3523 строк)
6.20/6.22

для всего проекта compile:
comp: 41.68 - 40.20 - 39.80 - 37.54(hash) - 37.90(const)/37.70(+const)/38.12?(addaddpoi)/37.58(без ds *) - 38.82(метки типов) - 42.16(локалы) - 43.14(поиск типа) - 46.60(структуры) - 46.34/46.88/47.34/46.52/46.54/46.52?(быстрый токенизатор)
tok: 46.04 - 44.40 - 43.10 - 43.06(hash) - 42.86(const)/42.36(+const)/42.12(addaddpoi)/42.54(без ds *) - 44.40(метки типов) - 44.40(локалы) - 44.92(поиск типа) - 47.02(структуры) - 48.16/48.42/48.04/48.36/47.74?(быстрый токенизатор)
asm: 54.28 - 52.26 - 51.28 (11365 строк) - 45.58(hash)/41.90(hash400) - 42.16(const)/42.28(+const)/42.06(addaddpoi)/41.12(без ds *) - 42.26(метки типов) - 42.56(локалы) - 42.36(поиск типа) - ?(структуры) - 44.98/44.78/44.16/44.26?(быстрый токенизатор)
итого: 142 - 137 - 134.28 - 126.62(hash)/122.50(hash400) - 122.92(const)/122.34(+const)/122.30(addaddpoi)/121.24(без ds *) - 125.48(метки типов)
 это из 4814 строк на недоланге (141447 байт - уже 132xxx байт) и 998 строк на ассемблере (16117 байт). То есть общая скорость сборки 41 строка в секунду (1,1 КБ/с).

для всего проекта asm:
comp: 21.46 (много комментов в fmttg, много констант с +) - 20.26(hash) - 20.24(const)/20.20(+const)/20.10(addaddpoi)/20.18(без ds *)/20.04 - 20.80(метки типов,локалы) - 20.96(поиск типа) - 21.98(incbin,export)
tok: 21.98 - 21.76(hash) - 21.64(const)/21.42(+const)/20.98?(addaddpoi)/21.00 (без ds *)/21.46?! - 21.60(метки типов,локалы) - 21.42 (поиск типа) - 21.58(incbin,export)
asm: 34.60 (много занимает заполнение нулями) - 31.64(hash)/29.92(hash400) - 29.30(const)/29.16(+const)/29.18(addaddpoi)/28.82(без ds *)/28.84 - 29.00(метки типов,локалы) - 28.66(поиск типа) - 29.64(incbin,export)
итого: ~74 - 71.18(const)/70.78(+const)/70.26?(addaddpoi)/70.00(без ds *)

для всего проекта tok:
comp: 27.48 (много комментов в fmttg) - 25.92(const)/25.86(+const)/25.72(addaddpoi)/25.74(без ds *)/26.14 - 27.08(метки типов,локалы) - 27.22(поиск типа) - 27.84(структуры) - 28.82/28.76/28.52/28.90/28.70/28.92?(быстрый токенизатор)
tok: 28.76 - 28.60(const)/28.58(+const)/28.26(addaddpoi)/28.46(?!без ds *)/28.92 - 29.30(метки типов,локалы) - 29.36(поиск типа) - 29.46?(структуры) - 31.50/31.86/32.10/30.74/31.58/31.26?(быстрый токенизатор)
asm: 36.60 - 29.18(const)/29.08(+const)/28.70(addaddpoi)/27.94(без ds *)/28.60 - 29.22(метки типов,локалы) - 29.02(поиск типа) - 29.26?(структуры) - 31.84/32.18/31.66/31.74/32.04/31.48/31.72?(быстрый токенизатор)
итого: ~93 - 83.70(const)/83.52(+const)/82.68(addaddpoi)/82.14(без ds *)

инициализация меток для токенизатора = 0.1 с



в аласме время ассемблирования (один исходник уже загружен):
исходник JPEG viewer (аласм показывает 8980 строк) 12-13 секунд
итого 720 строк в секунду
исходник ACEdit (аласм показывает 12477 строк, экспортировано 10741 строка, но там много макросов) 19-20 секунд
итого 640 строк в секунду
(скорость падает с числом меток)



SDCC 3.6.0 --opt-code-speed --all-callee-saves:
 #6630 байт код с константами + #0036 байт константные массивы + #19c7 байт под данные = #802d

 IAR Z80/64180 C-Compiler V4.06A/W32
Command line  =  -v0 -ml -uua -q -e -K -gA -s9 -t4 -T -Llist\ -Alist\ -I../z80/inc/ main.c 
 #38b4 байт код + #1076 байт константы + #19c7 байт под данные (пишет уже сдвинутый адрес перед defs) = #62f1



In assessing the costs of using C, the cost of the compilations 
themselves has to be considered. This too we deem acceptable. For 
example, to compile and link-edit the entire operating system ("sys- 
gen") takes somewhat over nine minutes of clock time (of which 
seven minutes are CPU time); the system consists of about 12,500 
lines of C code, leading to a rate of about 22 lines per second from 
source to executable object on a PDP-11/70. The compiler is faster 
than this figure would indicate; the system source makes heavy use 
of "include" files, so the actual number of lines processed by the 
compiler is 38,000 and the rate is 65 lines per second.
https://archive.org/stream/bstj57-6-1947/bstj57-6-1947_djvu.txt


проект начат 22ix16 (или раньше? нет более раннего файла), к 05x16 написано 1240 строк кода и 16К текста

на 9iii2017 основная часть компилятора (без main.c, но с nedodefs.h):

*.c (8), *.h (3):
188271
5700 строк

*.asm (включая затычки системных процедур):
332639 (ftokenized: 294874)
14398 строк

compiled by NedoLang:
42956

compiled by IAR (typedef unsigned int intptr_t):
..\z80\bin\iccz80 -v0 -ml -uua -q -e -K -gA -s9 -t4 -T -Llist\ -Alist\ -I"../z80/inc/" main.c
(стартапа в коде нет)
Code size: 18019
Constant size: 2858
Static variable size: Data(12067) Iram(0)
итого 32944

compiled by SDCC 3.6.0 (typedef unsigned int intptr_t):
sdcc -mz80 --code-loc 0x0006 --data-loc 0 --no-std-crt0 --opt-code-speed --all-callee-saves main.c -o %temp%\out.ihx
(стартапа в коде нет)
39801


23viii17 отладка в Phyton.
во всём проекте 20487 строк кода, 550761 байт
примерно 64 отлаженных строки в сутки (20487/320), но реально 13xii16 написан асм, а снова разработка продолжена 10i17
были ещё паузы на написание НИР, прокачной стенд, переводы, командировки, совещания и др.

(slow)io занимает лишних 2093 байта? перекомпиляция с iofast дала разницу только 1241 байт.
