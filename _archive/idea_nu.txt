в самом компиляторе рекурсия будет выглядеть так:
BOOL(leftsaved:
{testtest}
...
{одна ветка}
CALL(compile_expression,leftsaved(TRUE)) {после этого вызова нельзя использовать leftsaved - надо правило как в Rust}
...
{другая ветка}
CALL(compile_expression,leftsaved(FALSE)) {после этого вызова нельзя использовать leftsaved - надо правило как в Rust}
...
{testtest}
...
)

!!!или лучше чтобы объявление локала и контекст локала были раздельно:
(
BOOL(leftsaved)
STRING(curvariable)
{testtest}
...
{одна ветка}
STRING(curvariable:
  BOOL(leftsaved:
    CALL(compile_expression,leftsaved(TRUE))
  )
)
...
{другая ветка}
BOOL(leftsaved:CALL(compile_expression,leftsaved(FALSE)))
...
{testtest}
...
)
!!!или в вызове все перечисленные параметры сохранить автоматически, а контекст оставить только для локалов (не параметров)?
это нужно только для рекурсивных процедур, т.е. надо хранить тип процедуры (PROC/RECPROC)!
в Паскале для этого надо передавать тип процедуры сквозь все compile_xxx, а в NedoLang это не требуется, просто используем текущее значение флага
или для рекурсивных вызовов использовать CALLREC - он будет сохранять все параметры перед их заполнением, потом вспоминать обратно
но надо запоминать ещё локалы
можно генерировать автоконтекст у всех локалов процедур типа RECPROC (все контексты должны закрываться одной и той же закрывающей скобкой функции?)
список параметров процедуры надо тогда в отдельной скобке
ЭТО ТОЛЬКО ПРИ ОДНОМ ВЫХОДЕ ИЗ ПРОЦЕДУРЫ! или надо делать goto _exit
если так будет, то можно заодно проверять тип процедуры при её вызове (закодировать тип так: ttop.proc..INT..INT или для рекурсивной rtop.proc..INT..INT)
в именах переменных тип кодировать нельзя (т.к. внутри выражений он не пишется)

что из себя представляет рекурсивный вызов? сохранение параметров и заполнение их новыми значениями + вызов + восстановление
это можно сделать только при вызове, а не при входе в процедуру
то есть при вызове надо знать весь список параметров или генерить push'и одновременно с генерацией параметров (рекурсивно!)
а в описании самой рекурсивной процедуры нужно сгенерировать контексты всех локалов (тогда у неё нельзя несколько выходов по ret, но можно прыгать в конец)

описание контекста всех локалов:
stacked(<vars>)<command>
это в контексте разбора команды в объявлении процедуры, тогда ещё не поздно повлиять на тип процедуры, записанной в список процедур
причём все сохранения надо вести без порчи результата функции
результат сейчас в hl, но может быть в других регистрах для других типов данных!!!
как быть?

как определить тип функции:
func:int(name)stacked(int(var1)int(var2))command(retexpr)
или чтобы проще разбор:
func(name:int)stacked(int(var1)int(var2))command(retexpr)
stacked() не может быть пустой!




как сделать выгодную генерацию sub (чтобы не переставлять аргументы)?
разбор выражения с конца нереально, а генератор кода стоит в самом value, т.е. не переставишь
сейчас так:
  emit('        EX DE,HL');
  emit('        POP HL');
  emit('        OR A');
  emit('        SBC HL,DE');
это 33 такта, через восьмибитные команды будет минимум 34
8-битное вычитание (если в старшем бите):
pop af
sub h
ld h,a
тайпкаст 8->16:
ld l,h
ld h,0
тайпкаст 16->8:
ld h,l
но так неудобно сохранять 8-битные переменные (использовать 16-битные как 8-битные? так будет невыгодно делать структуры):
pushvar:
push hl
ld a,()
ld h,a
popvar:
ld a,h
ld (),a
pop hl

если же 8-битная работа идёт в a (так выгоднее poke), то:
sub (так же невыгодно):
ld c,a
pop af
sub c
тайпкаст 8->16 (так же невыгодно):
ld l,a
ld h,0
pushvar (выгодно):
push af ;как учесть, что на вершине может быть 16-битное?
ld a,()
popvar (выгодно):
ld (),a
pop af
тайпкаст 16->8 (так же невыгодно):
ld a,l

можно добавить операцию \- для обратного вычитания

что если генерить push отдельным вызовом перед рекурсивным вызовом expression (но не при вызове через let,if,while)?
нет смысла в push для "(a+b)+c"
если просто expression "a+(b+c)", то (для 16-битных) push hl:..., (для 8-битных) push af:...
если с тайпкастом 16->8, то push af:...:ld a,l
если с тайпкастом 8->16, то push hl:...:ld l,a:ld h,0

(a+b)+c:
;expr
 ;expr
  ;value
ld hl,[a]
  ;end value
push hl ;генерируется при операции
  ;value
ld hl,[b]
  ;end value
pop de    ;
add hl,de ;продолжение операции
 ;end expr
push hl ;генерируется при операции
 ;value
ld hl,[c]
 ;end value
pop de    ;
add hl,de ;продолжение операции
;end expr

или (мечта):
ld hl,[a]
ld de,[b] ;только для правого mulvalue, причём при любой вложенности сразу запрещать!
add hl,de
ld de,[c] ;только для правого mulvalue, причём при любой вложенности сразу запрещать!
add hl,de

или при вложенности не запрещать, а генерить push hl:...:ex de,hl:pop hl
это касается только вложенностей с операциями или вызовами
или глобальная переменная leftsaved "первый операнд сохранён"
(сбрасывается в начале выражения (или после генерации первого операнда?) и устанавливается после сохранения, если надо)
но с глобальной переменной не получится рекурсивно
надо передавать leftsaved=false в правый mulvalue (в левом leftsaved=true), а оттуда в value
если в num, var, const: leftsaved=false, то читаем через de, иначе через hl (ещё можно разные ветки в унарных -, ~, *)
если рекурсивное выражение, то генерить push hl, expression(leftsaved=true), ex de,hl:pop hl (в коммутативных операциях можно pop de, тогда правый операнд через hl без push)
конкретная реализация push...pop зависит от типа левого операнда
для полной оптимизации может понадобиться asaved, hlsaved, desaved, bcsaved
но это надо всё отслеживать в кодогенераторе!!! как там обеспечить хранение вложенности?
или как-то без хранения вложенности?



как сделать выгодную генерацию возврата из функции (чтобы не делать лишние push-pop)?
сейчас так:
;proc(dup)(
; return(1)
;)
tdup:
;BEGIN COUNT
;PUSHNUM 1
        PUSH HL ;не нужно
        LD HL,0+1
;SKIP
        POP DE ;не нужно
;END COUNT
        RET
вызов через push hl:call
!!!а если вызов через call:push de, то то же самое (но стек меньше!):
;val ret
push hl
;val ret top
ld hl
pop de
;val ret
ret
;val
push de
;val top
;надо val top

если сделать разбор выражений как выше, то автоматически не будет push:...:pop
вызов будет выглядеть так:
для левого операнда: call
для правого операнда с leftsaved=false: push hl:call:ex de,hl:pop hl
для правого операнда с leftsaved=true: call


32-битные числа хранить как два 16-битных, в hl только младшая часть нового (иначе придётся где-то делать push-pop вокруг 8- и 16-битных операций - в тайпкасте?)
add32:
;val1h val1l val2h
pop bc ;val2h
pop de ;val1l
add hl,de ;val2l+val1l
ex de,hl
pop hl ;val1h
adc hl,bc ;val1h+val2h
push hl
ex de,hl
;valh

sub32: (из старого вычитаем новое)
;val1h val1l val2h
pop bc ;val2h
ex de,hl
pop hl ;val1l
or a
sbc hl,de ;val1l-val2l
ex de,hl
pop hl ;val1h
sbc hl,bc ;val1h-val2h
push hl
ex de,hl
;valh

а если в hl старшая часть:
;val1h val1l val2l? нарушен порядок!
;val1l val1h val2l? не хватит регистров!

а если val2 в debc (8 команд вместо 10 за счёт push:pop):
;val1h val1l
pop hl ;val1l
or a
sbc hl,bc ;val1l-val2l
ld c,l
ld b,h
pop hl ;val1h
sbc hl,de ;val1h-val2h
ex de,hl

а если val2 в bcde (то же)
pop hl
or a
sbc hl,de
ex de,hl
pop hl
sbc hl,bc
ld c,l
ld b,h

debc или bcde неудобно сдвигать (т.к. параметр сдвига надо в b и нет быстрого hl)
вся проблема из-за обратного порядка sub
;сдвигаем старое на "новое" бит влево (новое в A)
or a
jr z,_skip
ex de,hl
add hl,hl
rl c
rl b
dec a
jr nz,$-1-2-2-1
ex de,hl ;по сравнению в sla e:rl d проигрыш (только на 1 бите) 3 такта, выигрыш 1 байт
_skip:
но можно специально выделить bcde под 32-битные, hl под 16-битные, A под 8-битные
(на ARM в этом нет смысла)


BOOL можно хранить в F (проще всего CY), тогда if/while прямо по флагу
 AND:
jr FALSE,$+2+2
pop af
push af
pop bc
 OR:
jr TRUE,$+2+2
pop af
push af
pop bc
 XOR (только для флага в CY):
jr FALSE,$+2+3
pop af
ccf
push af
pop af
 pushvar (только для флага в CY):
push af ;зависит от типа выше
ld a,(var)
rlca
 popvar (только для флага в CY):
rrca
ld (var),a
pop af ;зависит от типа выше
 LESS (старое меньше нового):
;если leftsaved=FALSE
;ex de,hl
;pop hl
or a
sbc hl,de
 MORE (новое меньше старого):
;если leftsaved=FALSE
;ex de,hl
;pop hl
ex de,hl
or a
sbc hl,de
 MOREEQ (старое >= нового):
;если leftsaved=FALSE
;ex de,hl
;pop hl
or a
sbc hl,de
ccf
 EQ:
;если leftsaved=FALSE
;ex de,hl
;pop hl
or a
sbc hl,de
jr z,$+2+1 ;CY=0
scf
ccf
 NOTEQ:
;если leftsaved=FALSE
;ex de,hl
;pop hl
or a
sbc hl,de
jr z,$+2+1 ;CY=0
scf



неудобно, что проверка int/uint стоит в двух местах - в compile_command и в compile_var
надо бы символ-префикс, который обрабатывать как команду?
тогда не будет и пересечения по первой букве

надо присваивание типизированное
пусть для начала два типа: int и uint
тип можно писать явно, а можно брать из типа переменной
поскольку мы не можем проверять всё дерево, надо, чтобы каждый член выражения был того же типа
как оформлять приведение к типу?
сравнение в if, while тоже типизированное? там негде писать тип, переменной тоже нет!
сделать сравнение всегда одного типа? но как потом сравнивать float'ы?
???
а)
вместо read_compile_expression иметь две процедуры (без readcommand):
compile_logvalue (ожидает сравнения и логические операции [может использовать bool?], вызывает compile_sumvalue)
compile_sumvalue (value вызывает его, а не сравнения и логические операции)
[bool присваивать через compile_logvalue]
б)
никаких bool, только жёсткие сравнения и "and if"/"or else" в условиях?
в) полноценно - реализовано

неудобно без else if, т.к. обязательная скобка после else
сделать специальное слово elsif?
или вместо else просто ставить команду? или ~команда?
/*
выигрыш, если каждую команду читать с конца (или хранить задом наперёд в тексте):
деление удобно лежит по регистрам
вычитание удобно лежит по регистрам (но для полубайтного кода popantisub удобнее на 1 байт)
присваивание после вычисления
ветвление после вычисления
префиксы (адресация, разадресация, унарный -, инверсия) после вычисления, но префиксы hex,dec до вычисления

на этом можно построить совершенно другой синтаксис типа:

int(expr)var
int(expr)if()then()else
*/



//стоит ли сделать общую процедуру stacked и вызов процедур писать как =<par>(<expr>)=<par>(<expr>)?<title>
//где ?<title> стоит в поле команды
//проблема, что при вызове без stacked меняется весь порядок: =<par>(<expr>)=<par>(<expr>)?<title> или вообще без параметров (через присваивание)
//к тому же в заголовке процедуры не <par>(<expr>), а <type>(<par>)

команды, доступные из компилятора, должны выглядеть так:
emitcomment(';name');
emitop(getoldreg,getnewreg); //когда занимает незаказанный регистр, помечает его и убирает из стека номеров свободных
emitop(getnewreg); //когда освобождает незаказанный регистр, возвращает его в стек номеров свободных
...
//newreg, oldreg могут достать регистр из физического стека



как компилировать под несколько процессоров:
а)
ветки в каждой процедуре emit... (другие варианты, другие коды команд, другие таблицы названий регистров)
число регистров не должно отличаться
б)
отдельный кодогенератор как программа
неудобно будет отладить передачу данных от компилятора к кодогенератору
и будет тормозить
в)
объекты emitasmz80, emitasmarm, наследованные от одного класса emitasm
неудобно будет переписывать компилятор на свой язык
г)
структура с адресами всех процедур emit...
заполняется в initz80 и initarm (вызываем одну из двух)
д)
код для каждого таргета в отдельных файлах, генерируется отдельный экзешник
как собирать из разных файлов? через копирование? или собрать все машиннозависимые инклюды в одном главном модуле?


/*
если нет stacked(type(var)type(var)...)command:
вместо par:int(v1)(command) можно так:
INT(v1(command)) - нельзя, там параметр массива - а что если блок команд в скобках []? двойные скобки всё равно нехорошо
INT(v1:commands)
*/
тип в поле команды - это не куча похожих обработчиков, а один обработчик с параметром

Можно сделать префикс к переменным (как в PHP и bat)
Но у чисел нет префикса, поэтому придётся их склеивать
Если у переменных есть префикс, то присваивание можно следующим образом:
=a(expr)
*a(expr) - poke {редко нужно)
При адресации двойной префикс, потому что бывает *(expr). поэтому *=a
При разадресации не бывает @(expr). поэтому можно @a
Проще переменные склеивать, как и числа, предусмотреть длину 1


 можно префикс < для перевода byte/uint в uint и сдвига на 1 бит (а как без сдвига? через &) "<(сколько)что" ?

  //или различать -num против -var и -(expr), т.е. надо читать на 1 символ вперёд 
 //или запретить писать -var, -(expr), разрешить только -+value (парсится как операция "-" от +value, а +value парсится как просто тайпкаст "+" от value, проблема с -+#8000 - не пройдёт range check), но как тогда парсить -2? выделять уже на уровне слова???

просваивание переменной:
=a(expr)
INT=a(expr)
INT(a=expr)
варианты с переменной в конце:
INT(expr)=a; - требует ;
INT(value=a) - будет ошибка при INT(2+2=a). закрывать все expr по = нельзя, т.к. внутри value стоит (expr), а два признака закрывания - жирно
INT=value(a) - та же проблема - будет ошибка при INT=2+2(a)
value=INT(a) - value в поле команды! как тогда объявлять функции?
  нужно придумать выражение для присваивания массива с элементом любого типа
  присваивание элемента массива сейчас так:
//чтобы записать ячейку массива: команда *(@<var>+<index>*2)<value>
*(@array#+[7*WORDSIZE])(555)
  а надо что-то вроде такого:
ARRAY=a,INT=value(expr)
[value]a(expr)
=a[value](expr)
INT=a[value](expr)
INT(a[value]=expr)
INT(a(expr)=expr)
(a[value]=expr) нельзя, т.к. ( команда блока команд

как выглядит объявление переменной?
INT(a) - но тогда ветвление уже довольно глубоко в операторе присваивания: ")" против "="
INT(a[N])
сейчас так:
+int(a) - объявление
=a(expression) - присваивание


//чтобы прочитать ячейку массива: *(@<var>+<index>*2)

if<expr><command>
~<command> //else<command>

# true, false - как? выглядят как переменные, но реально константы!
/*&*/true и /*&*/false нельзя, т.к. должны быть глобальными
делать просто дефайнами и подключать другие модули? как соблюсти тип bool?


# использовать для глобалов /*$*/, который будет у нас восприниматься как '$'? не работает!!! потому что nextsymbol='/'
# что делать с вызовом функций в вычислении? нельзя начинать с буквы, надо выбрать знак, который ни на что не влияет
'+' влияет в нашем языке (делает INT из BYTE/UINT)
для "*&" нужно кучу типов указателей
использовать /*?*/, который будет у нас восприниматься как '?'?
# хотя бы один совместимый комментарий, например, // и/или /** */
# для вставки уникального сишного кода нужен комментарий, который в си будет как кусок кода/выражения/чего угодно
для такой задачи не нужна вложенность
Borlard C++ Builder ругается на "\{" и "\ "
делать просто дефайнами и подключать другие модули?
# константы в стиле Си

или наоборот? .localvar, globalvar, .submodule.var, anothermodule.var


(submodule.var, _anothermodule.var не будет работать)
было _.thismodule.submodule.var (надо знать весь путь!!! и то с хаком выкидывания лишней '.')
 
мы не знаем имя текущего модуля (оно может иметь много точек из-за вложенности)
надо строить так:
переменные как 't'+module+title+var
метки как '_'+module+title+label
автометки как 'l'+module+title+autolabel
?


что делать в if/while:
[можно такие же автометки использовать в if/while, но там надо две сразу и потом делать undef (как отличать в post labels несколько одноимённых меток, которые относятся к разным циклам?)]
или предусмотреть в ассемблере специальные блоки с запоминанием адресов в стеке:

;сдвиг уровня вложенности
_lll..ll:
<условие>
PUSH $TEMPLABEL ;здесь генерируется уникальный идентификатор $TEMPLABEL, а старый кладётся в стек
GEN $TEMPLABEL
 jp cc,$TEMPLABEL ;подменяется на идентификатор
 <тело>
 jp _lll..ll
$TEMPLABEL ;подменяется на идентификатор
POP $TEMPLABEL ;вспоминает из стека старый $TEMPLABEL
;возврат уровня вложенности (встроен в emittemplabelundef)


<условие>
PUSH $TEMPLABEL ;здесь генерируется уникальный идентификатор $TEMPLABEL, а старый кладётся в стек
GEN $TEMPLABEL
 jp cc,$TEMPLABEL ;подменяется на идентификатор
 <тело then>
$TEMPLABEL=$+3 ;подменяется на идентификатор
POP $TEMPLABEL ;вспоминает из стека старый $TEMPLABEL
PUSH $TEMPLABEL ;здесь генерируется уникальный идентификатор $TEMPLABEL, а старый кладётся в стек
GEN $TEMPLABEL
 jp $TEMPLABEL ;подменяется на идентификатор
 <тело else>
$TEMPLABEL ;подменяется на идентификатор
POP $TEMPLABEL ;вспоминает из стека старый $TEMPLABEL

или с $TEMPLABELELSE, $TEMPLABELENDIF, тогда не будет $+3

[можно было бы вместо GEN $TEMPLABEL реализовать что-то типа SET $TEMPLABEL=$TEMPLABEL+"_" или "{{$TEMPLABEL}}_"
но тогда надо перед POP поставить UNDEF $TEMPLABEL и опять та же проблема с post labels!!!]

[или LOCAL-ENDL, который делает частичную обработку post labels (все нельзя - они не готовы) и undef - как?]
???
[ассемблер может делать эквивалентными метки с эскейпами?
<calltitle1><esc><calltitle2> = <calltitle2>??? но видимость внутри calltitle1 не такая, как надо при вызове!
]


# названия меток склеиваются через:
function prefixjoinwordscommand(prefix:char; word1:AnsiString):AnsiString;
function prefixjoinwordsgenlabel(word1:AnsiString):AnsiString;
если передавать префикс отдельно, то нельзя вложенные модули (и сейчас они плохо работают - нет нормального доступа к субмодулям без использования имени модуля)
при входе-выходе из подмодуля переприсваивание меток не поможет, т.к. дело касается всех меток
можно ожидать от ассемблера крутой реализации директивы LOCAL, но вряд ли (проще реализовать строки или стек)
в любом случае надо хранить имя модуля (это ещё можно убрать, если модулей нет) и имя процедуры (а тут проблема с локальными именами!)
достаточно иметь массив чаров со встроенной длиной, тогда можно склеивать строки и отклеивать имя подмодуля



# компилировать констатный стринг как строковую константу + указатель на неё
(можно без номера константы, если компилятор будет внедрён в БОСК, но такая же замена с номером строки планируется в БАЗИСе, т.к. наш язык заменим на Си)
а как это сделать в Си???
# заменить в исходнике все неконстантные стринги на массивы чаров и длину

можно ли стримить command? только если переложить пространства имён на ассемблер? или выводить label по частям? или label должен видеть все части + резать левую часть по точкам?


 нужны ли в таком простом языке символьные типы? (не байты!!!)
 по идее нужно только номера символьных констант и параметров (при вызове из командной строки), никаких операций над строками, а символьные константы генерить в отдельный модуль, чтобы их можно было скинуть в другой процесс
как реализовать строковые типы?
1. как массив чаров (для склеивания)
2. как указатель на константную строку или массив чаров (уже склеенный)

можно убрать insinglequote, indoublequote, а строковые константы разгребать по аналогии с readparentheses




/*если регистр - токен, а не параметр токена, то при встрече редких ix/iy, regx, i/r, (bc/de), (ix/iy+) можно менять базу или даже ломать формат (например, писать префикс или даже начать разбирать вручную)
поскольку (ix+) встречается в команде не более одного раза, то он может сам писать dd*/

/*можно запись dd делать так:
if(!wasdd) {
  write(dd)
  wasdd=TRUE
}
а где сбрасывать wasdd? его могла установить куча команд. сбрасывать во всех конечных токенах? во всех начальных слишком жирно*/







else /*if(asmmatch_regbyname()) {
      if(asmmatch_regbyname()) asmtoken(ASMFMT_INCRP);
    else if(asmmatch_regbyname()) asmtoken(ASMFMT_INCR);*/
  
    if(c1==CREGBYNAME){
      readcommand_tokenize_space();
      if(c1==CREGBYNAME){ //getrpbyname
        readcommand_tokenize_space();
        asmtoken(ASMREG_RPBYNAME);
        asmtokenize_command();
        asmtoken(ASMFMT_INCRP);
      }
      else { //getregbyname
        asmtoken(ASMREG_RBYNAME);
        asmtokenize_command();
        asmtoken(ASMFMT_INCR);
      }
    }

    
//различать rbyname и rpbyname требуется только в inc и dec
//поэтому можно ввести отдельную команду incrp *rpbyname (совместимость не требуется, т.к. такого нигде нет)
//inc *метка парсится как incrp *rpbyname


   //регистры (60 шт, можно меньше - см. ниже):
//B (*8) для inc b (с выходом) и ld b,a (без выхода)
//
//C (*8)
//
//D (*8)
//
//E (*8)
//
//H (*8)
//
//L (*8)
//
//[HL] (*8)
//
//A (*8)
//
//B (*1) для ld a,b (с выходом), rl b (с выходом), bit 0,b (с выходом)
//C (*1)
//D (*1)
//E (*1)
//H (*1)
//L (*1)
//[HL] (*1)
//A (*1)
//[BC] (*10) для ld a,(bc) (с выходом) и ld (bc),a (без выхода)
//
//[DE] (*10)
//
//[SP] (без выхода) можно привязать внутреннюю константу к DE (ex de,hl против ex (sp),hl)
//BC (*10) для inc/dec bc (с выходом), adc/sbc hl,bc (с выходом), ld [NN],bc (с выходом), push/pop bc (с выходом), ld bc,NN/[NN] (без выхода) - везде нужна запись
//DE (*10)
//DE для ex de,hl (без выхода и без записи)
//HL (*10) бывает ещё в ex de,hl, jp hl, ex (sp),hl (с выходом)
//HL для add/adc/sbc hl,rp (без выхода и без записи)
//AF (*10) (с выходом)
//AF для ex af,af' (без выхода)
//SP (*10) - та же внутренняя константа, что в AF
//IX (*20) (с выходом и без выхода) с записью
//IX для add ix,rp без записи
//IY (*20)
//IY для add iy,rp без записи
//[ для [ix+-N], [NN] - должна быть как команда, ничего не делает
//] для [ix+-N], [NN] - должна быть как команда, ничего не делает
//HX (*8) для inc hx (с выходом) и ld hx,a (без выхода)
//
//LX (*8)
//
//HY (*8)
//
//LY (*8)
//
//HX (*1) с выходом
//LX (*1)
//HY (*1)
//LY (*1)
 //AF' (с выходом) можно привязать внутреннюю константу к DE (ex de,hl против ex af,af')
 //I (*8) для ld a,i (с выходом) и ld i,a (без выхода)
 //
 //R (*8)
 //
//rpbyname
//rbbyname

//можно ещё меньше, если две команды: <reg><N*8>, <reg_write><N*8> (и <reg_write><N>)
//или <mul1_add>N, <mul8_add>N, [<mul10_add>N,] <write> - так удобнее для подмены регистров
//подмена регистров: <label_mul1_add>LABEL, <label_mul8_add>LABEL
//или у каждой команды в конце команда write нужного типа: <writecmdreg8>, <writecmdreg8reg1> и др. (так удобнее разбирать команду и можно сделать всего один тип ld? тогда надо дополнительную команду <setbase>N или размножатся типы write)
//тогда у каждого регистра ровно один код


//plus_push
//minus_push
//mul_push
//div_push
//and_push
//or_push
//xor_push
    //все выше можно заменить на push с пропуском символа
//plus_push0 (кончается на endplus_add)
//minus_push0 (кончается на endminus_sub)
    //выше можно заменить на push0 с пропуском символа
//inv_pushffff (кончается на endminus_sub или endxor_xor)


  //типы ошибок:
//wrong expression
 //wrong expression / no closing bracket
//wrong parameter
 //wrong register or direct expression
 //wrong register
//no comma (',' expected)
//no closing bracket (')' expected)
//no direct prefix ('#' expected)

//endplus_add - можно так делать конец любой операции (операция будет сохранять в стек свой код)
 //endminus_sub
 //endmul_mul
 //enddiv_div
 //endand_and
 //endor_or
 //endxor_xor
//getvar_or_macropar



Дефайны для нашего языка?
#define _TRUE ?0xff
#define _FALSE ?0x00
#define CALL @.
#define WORDSIZE 2 /*зависит от процессора*/

если не делать ++, то можно тайпкаст к лонгу (signed) сделать в виде + +num (на Си работает)
или можно разделить случаи по числу пробелов


чтобы не проверять тип функции при вызове (т.к. она может быть определена ниже), можно сделать вызов функции такого вида:
@<type><title>([<stacked>][<par>=<expr>...])
но параметры тоже не определены! в них тоже писать типы?
при повторном определении функции и переменной просто проверять тип
как при этом проверять глюки повторного определения?

в nedolang можно убрать точку перед вызовом функций, но ставить её при генерации асма (если не глобальная, а вложенных всё равно нет)
а как организовать доступ к общему модулю из разных модулей? только как к глобальному?
тип перед именем функции теоретически можно загнать в скобки (для Си это тайпкаст)
но как определить факт вызова? если бы типа спереди не было, то можно было бы определить факт вызова по постфиксу '('

_type(xx)var
_cast(xx)_type(xx)var
_cast(xx)_type(xx)_global var - нам нужен тайпкаст только для указателей, остальные преобразования можно операторами

тайпкаст только для указателей:
  void *p;
  p=a; //указатель=массив
  c1=*(char*)p;
  *(char*)p=c2;
в нашем языке это пишется так:
  VAR POINTER p;
  LET p=a; //указатель=массив
  LET c1=*(char*)p;
  LET *(char*)p=c2;

как отличить запись с тайпкастом от записи без тайпкаста? всегда тайпкаст

* recursivevar - определить переменную внутри рекурсивной процедуры/функции. Оформляется так же, как var. Если внутри рекурсивной процедуры/функции определить обычную переменную, то её значение испортится при рекурсии. Нельзя так объявлять массивы.

/*
?reccall - а как вызывать из выражения? или вызывать как обычно, а тип будет определяться из типа процедуры? (надо создать список процедур или включать процедуры в список переменных) если в процедуре есть хоть один stacked, то она рекурсивная - это нужно включить, как только видим stacked, потому что вызов может быть тут же

?return/result? out/outcome? produce/product? effect? - можно просто в конце функции добавить поле результата
*/


проверять типы прямо в парсере выражений:
read_compile_expression должен иметь параметр "type"
все его подпрограммы должны возвращать тип прочитанного значения
при выходе из read_compile_expression проверяется соответствие полученного типа
тип переменной читается из таблицы меток (переменных)
тип dec константы - uint
тип hex константы - byte/uint/long (зависит от числа символов)
тип float константы (с точкой) - float
если операция +, а аргументы разного типа или типа bool, то ошибка
если операция *, а аргументы разного типа или типа bool, то ошибка
если операция \| \& \^, а аргументы не оба bool, то ошибка
нужны префиксы для uint(int) (редко нужно), для int(uint) (часто нужно), ...
префикс "+" может преобразовывать byte/uint в int без смены знака. лишней операции не образуется (но можно добавить рантаймовый range check)
префикс "-" может преобразовывать uint в int со сменой знака. как убрать лишнюю операцию?
 писать +[-num]
как расширять byte в uint, uint в long - через uint&byte, long&uint
как выделять байты из слов - через uint&byte

если можно складывать/вычитать/применять лог.операции к int+uint (равенство деление = div ничего не значит), то нельзя при обработке операции заранее знать тип аргументов
но нам и не нужно знать заранее

сейчас всё абсолютно строго! если нужен int, то используем префиксы +,-, а если нужен uint, то используем int&uint
тип результата & по правому (вообща надо по самому узкому) операнду (но не для прочих логических операций)


сделать явные префиксы типа переменной, чтобы не читать его из таблицы переменных?
так будет трудно менять тип переменной при рефакторингах программ
хотя есть автозамена
это всё равно что венгерская нотация

если без таблицы меток:
контроль типов можно возложить на ассемблер, если к каждому слову приписывать тип
но для этого надо откуда-то знать типы переменных, и при присваивании, и при чтении!
случаи:
1. параметр функции - добавить тип легко (т.к. уже есть /**/)
2. чтение глобала
3. запись глобала
4. чтение локала
5. запись неменяющегося локала (можно совместить с определением)
6. запись меняюшегося локала
7. вызов функции - добавить тип легко (т.к. уже есть /**/)

можно _xxxxxxx в контексте терма зарезервировать не под глобалы, а под подсказки компилятору (в Си там будет пусто)

или весь набор типов продублировать с подчёркиванием? (как тогда расширять систему типов?)
или кодировать тип в имени переменной (как тогда расщирять систему типов?)
ivar
uvar - нет в венгерской нотации?
lvar
cvar - нет в венгерской нотации
bvar - в венгерской нотации это bool или byte
fvar - хотелось бы для flag (бывает иногда в венгерской нотации)
pvar - в венгерской нотации не пишется тип указателя?
это плохой стиль венгерской нотации (хороший - это класс значения или его размерность)

для глобальных можно придумать префикс? (в венгерской нотации g_)


писать localvar, _globalvar, .thismodulevar, ..parentmodulevar, .submodule.modulevar
можно реализовать это прямо в ассемблере (все области видимости определить как LOCAL @word, склеивание с учётом точек внутри word)
обратиться к подпроцедуре - просто без точки (или подпроцедуры не нужны?)
если компиляция в один проход без post labels, то надо вложенные процедуры (не поможет для expression<->value и expression<->call) или forward заголовки
нельзя _.anothermodule.var



Сделать префикс + для тайпкаста и вызова функций?
+(type)(var)
+(type)func(...) - это либо сделать value без readcommand, либо передавать в value прочитанный тип (или просто иметь глобальную переменную - прочитанный тип)
+TRUE, +FALSE? (это уже не позиция переменной) или +(BOOL)TRUE, +(BOOL)FALSE? (в позиции переменной!!!) или проще писать +(BOOL)0x00, +(BOOL)0xff? или +(TRUE), +(FALSE)?

в параметрах вызов функции выглядит так: (type)func(...)
но будет странно: почему "тайпкаст" параметров выглядит по-другому, не как в выражениях, а вызов функции так же - они же были одинаковые
есть вариант в параметре вызывать не expr, а value с pretype, всё равно совместимость с Си это требует

ключевые слова не начинать на одну и ту же букву для скорости опознавания:
"?<name>(<params>)" (call? use?)
goto
if
module
/*proc*/
func
stacked (блок с сохраняемыми локалами, вместо описания процедуры через recproc)
case? (switch?)
while

можно такий синтаксис:
+type(var)
+type func(...)
в параметрах функций без "+"
как сделать везде без "+"???

хотя бы сделать без тайпкаста в параметрах и вызовах функций


можно без точек с запятой убрать LET (кроме POKE), но тогда остальные служебные слова пересекутся с идентификаторами?
можно избежать пересечения, если допустимы только форматы:
var=expr
var[expr]=expr
(var.var пересекается с if expr, если допустимы .val - сейчас недопустимы)

CALL убрать нельзя?
(proc(...) пересекается с if expr, while expr - делать do while? а do if неудобно - получится else do if, заменить на elsif? do вообще несовместимо с Си при строчных буквах)
(if+(...), while+(...)? несовместимо с Си!)
(+if(...) несовместимо с Си и приклеивается к предыдущему выражению)
можно определить IF expr THEN (как в Паскале):
#define IF if((
#define IFNOT if(!(
#define THEN ))
но тогда никогда не выкинем THEN
и несовместимо с Си при строчных буквах (можно тогда и WHILE expr DO так же несовместимо)
(можно ;if(...), но тогда не отличить от случая, когда прошлая команда оканчивается на ; (при нескольких командах в строке))
(i;f(...) в Си пересечётся с функцией f(...))

в compile 407 'call' и 227 'let' (переделан не полностью, а основная часть call - отладочные)
в reader 60 'call' и 81 'let', 25 'var', 84 'if'
оставить 'call'?
часть 'let' ещё войдёт в var



Сейчас слова читаются целиком, потом целиком обрабатываются.
Это неудобно для реализации на низком уровне.
но невозможно однократно использовать слово везде (надо же проверить тип)
кроме того, для правильного склеивания идентификатора надо знать, есть ли справа скобки ().



//#pragma once
#ifndef INCLUDED_REGS_H
#define INCLUDED_REGS_H
//#include "emits.h"
//#include "emitter.h"

//reg pool
PROC initregs(); //очистить состояния регистров и байтов (используется в cemitfunc)
PROC getnothing(); //сохранить регистры и байты в стеке и освободить
PROC setbytecontext();
PROC setwordcontext();
PROC reservereg(BYTE r1);
PROC unreservereg(BYTE r1);

//reg pool для word
PROC freenewreg(); //освободить регистр с вершины стека
PROC freeoldreg(); //освободить второй регистр с вершины стека //для long&reg
FUNC BYTE getfreereg(); //занять свободный регистр и вернуть его код
FUNC BYTE getnewreg(); //вернуть код верхнего регистра
FUNC BYTE getoldreg();
FUNC BYTE getveryoldreg();
FUNC BYTE getmainreg(); //взять MAINREG=new и освободить остальные регистры //для result, endfunc,endfuncbyte
PROC setmainreg(); //установить признаки, как будто мы получили результат в регистре //для call, call2regs
PROC getmain2regs(); //взять MAINREG=old, MAINREG2=new и освободить остальные регистры //для resultlong, endfunclong, call2regs
PROC setmain2regs(); //установить признаки, как будто мы получили результат в регистрах //для calllong

PROC emitpopreg(BYTE rnew); //todo убрать

//reg pool для 8 bit
PROC freenewa(); //освободить верхний аккумулятор
FUNC BYTE getfreea(); //занять новый аккумулятор (если не хватает аккумуляторов, старый сохранить в стек)
FUNC BYTE getnewa(); //вернуть код верхнего аккумулятора
PROC getmaina(); //взять new в главный аккумулятор (REGA) и освободить остальные аккумуляторы
PROC setmaina(); //установить признаки, как будто мы получили результат в аккумуляторе
PROC getoldanewa2(); //взять REGA=old, REGA2=new

PROC emitpopa(BYTE anew); //todo убрать

  BOOL bytecontext;
  BOOL aused;
  BOOL a2used;
  BYTE usedreg[NREGS];
  BYTE usedregscount;
  BOOL fastregused;
  BOOL fastreg2used;
  BOOL fastreg3used;
  BOOL fastreg4used;
/*
если свободных регистров не хватает, то надо зарезервированные сохранять в temp (этого не будет, т.к. резервируем только под результат)
если резервируемый регистр уже зарезервирован, то надо зарезервированный сохранять в temp (это бывает только для результата в A, сейчас вместо этого костыль с результатом в HL)
temp - если нет двойного резервирования, то по одной ячейке памяти на каждый регистр, флаг занятости ячеек даже не нужен в этом случае
стек зарезервированных регистров, чтобы разрезервировать в обратном порядке? реально надо резервировать только аккумулятор (ненадолго) или результат (на время poppar)

очередь usedreg должна быть построена так, чтобы можно было:
- быстро сохранять в стек (освобождать) самый нижний регистр и все
- быстро занимать-освобождать верх
а)
нужны указатели на регистр-начало и регистр-конец (а как при пустом логическом стеке? нули? или псевдорегистры-терминаторы?)
и каждый регистр должен указывать на предыдущий и следующий
б) сейчас просто массив сдвигается

кто кого должен вызывать:
compiler (универсальный)
>
commands (не содержат асм и указаний на регистры, т.е. универсальные)
>
emit... (без конкретных названий регистров?)
?getnewreg, getoldreg, getveryoldreg, (взять 1,2,3 регистр от вершины лог.стека и вернуть его код)
?getfreereg (занять регистр и вернуть его код)
>
getmainreg, getmain2regs (взять вершину стека в 1,2 самых приоритетных регистра, а остальные освободить)
getnothing (освободить все регистры)
getnewreg, getoldreg, getveryoldreg (взять 1,2,3 регистр от вершины лог.стека и вернуть его код)
getfreereg (занять регистр и вернуть его код)
freenewreg (освободить регистр)
reservereg (зарезервировать top)
unreservereg (разрезервировать в обратном порядке и занести на вершину лог.стека)
private freeoldestreg (освободить самый старый регистр и проверить, если ли ещё) - для getfreereg и getnothing
?private swapregs?
>
массивы регистров

*/

#endif//INCLUDED_REGS_H
//END



убрать временные метки на каждом присваивании

для смешанного регистрового контекста достаточно иметь в регистрах одновременно:
8, 16(top) (для regwfromregb) - но как потом освободить old?
16, 8(top) (для regbfromregw и peek - но как потом освободить old?) (и для poke)

пусть данные лежат только в 16-бит регистрах (regs не будет знать про аккумулятор)
и есть proxyreg (может быть 0x00, когда ничего нет)
codegen_initregs - делает proxyreg=0x00; initregs();, вызывается в начале генерации функции
unproxy() - делает ld reg,a (если надо)
proxy(reg) - делает ld a,reg (если надо)
если надо хранить в младшем байте, то push делает unproxy(), иначе можно ветку в push
getmem = proxy(getfreereg()); emit("ld a,[]");
putmem = proxy(newreg); emit("ld [],a"); unproxy(); freenewreg();
sub8 = unproxy(newreg); proxy(oldreg); emit("sub"+newreg); freenewreg();
добавить операции pusharg8, poparg8
везде, где временно нужен аккумулятор, сделать unproxy();
в ret8 сделать proxy(newreg);
в call8 сделать unproxy(getmainreg());

вызовы getreg, getnew, getold, getveryold, freereg,
freenew... (осталось в emitpokea, emitpeeka),
setwordcontext, setbytecontext вынести в commands

reservea, unreservea оставить в codegen (reservea должен делать ex af,af', если aused, и запомнить этот факт, а unreservea должен по этому факту обратно ex af,af' -
тогда эта пара процедур связана с regs только по переменной aused - но это тоже нехорошо?)

getmaina (для inv, put, poke) - оставить в codegen? (getmaina не используется в commands)
в put/poke можно сделать варианты в зависимости от aused (если aused, то ex af,af':ld a,anew:ld (),a:ex af,af', иначе ld a,anew:ld (),a - это тоже нехорошо?)
jpcc делать по флагу, а не по anew?
чтобы переходить по флагу, надо чтобы само чтение булевой переменной установило флаг. логические операции с ней правильно ставят флаг
но if(foo==bar) будет делать лишнюю операцию ztoa, необходимую для хранения булевой переменной

обработку условий склеить, чтобы не разрывать reservea...unreservea (сейчас там пустые процедуры, т.к. контексты word и byte взаимоисключающие)

добавить в regs: getmain3regs, getmain4regs

plus/minus/and/or/xorbyte... требуют aold==REGA!
то есть нельзя getplusbyte(getnewa(),getolda()); freenewa();
если вместо getolda() реализовать выделение REGA, то уже взятый newa надо будет переименовать!!!
subbyteflags сделано так:
  if(a2==REGA) {
    emitasm_const( "        CP " ); emitasm_const( REGANAME[a1] ); endasm();
  }else{
    emitasm_const( "        LD " ); emitasm_const( REGANAME[REGATMP] ); emitasm(','); emitasm_const( REGANAME[a1] ); endasm();
    emitasm_const( "        LD A," ); emitasm_const( REGANAME[a2] ); endasm();
    emitasm_const( "        CP " ); emitasm_const( REGANAME[REGATMP] ); endasm();
  }
но для and/or/xor/plus это невыгодно, т.к. аргументы равноправны
как сделать в commands освобождение не new, а того аккумулятора, который больше не нужен в codegen?
надо из codegen возвращать код регистра
и освобождать через freea (такого же freereg не существует, потому что в аккумуляторах строгий порядок и нет очереди)
это плохо?
надо сделать такой freea, чтобы можно было даже при наличии очереди делать freea(getplusbyte(getnewa(),getolda()));
и такой же freereg

сейчас freenewreg сделан так:
  getnewreg(); //а то вдруг нет в регистрах (надо ли ???)
  //очередь usedregs можно не трогать, просто сдвинуть голову очереди (счётчик)
  nousereg( usedreg[ usedregscount-1 ] ); //только сбрасывает флаг использования 
а надо найти регистр в очереди, удалить и закрыть дырку в очереди

если объединить контексты, то нельзя использовать REGATMP, а надо выделять регистр из codegen (а мы удаляем все выделения регистров из codegen!!!)
в codegen нам дополнительно доступен только af'
;b-c => b (нельзя в a, т.к. мы его только временно резервировали, да и освободить 2 регистра сразу на выходе не можем)
<reservea()>
ld a,b
sub c
ld b,a
<unreservea()>

;b-a => a
ex af,af' ;a'="a"
ld a,b
ex af,af' ;a'="b", a="a"
ld b,a ;b="a", a'="b"
ex af,af' ;a="b", b="a"
sub b

/*или
xor b
ex af,af' ;a'="a"^"b"
xor b
ld b,a ;b="a"
ex af,af' ;a="a"^"b"
xor b ;a="b"
sub b
*/
/*или
ex af,af' ;a'="a"
xor b
ld b,a ;b="a"^"b"
ex af,af' ;a="a"
xor b ;a="b"
...
sub b
*/
/*
или
<aold=reservea()> //возвращает регистр, куда попал аккумулятор
ld a,b
sub <aold>
<unreservea()>
а что делать, если нет свободных регистров? мы не можем освободить регистр, т.к. его номер мог быть выдан!!!
тем более если reservea работает через ex af,af'!!!
*/
/*патч ld (),a:ld a,b:sub N использовать нельзя, т.к. можем компилировать в ПЗУ (да и невыгодно =24t, как и выше)*/

или
<swapa(a,b)>
sub b

или (если аккумулятор - только прокси какого-то регистра) b-a => a
<unproxy(R)>
<proxy(b)>
sub R
...теперь аккумулятор - прокси чего? логично b
а на ARM? там надо знать оба регистра!
и emit должен сам уметь unproxy, когда заказывает временный аккумулятор!

при push(R) надо пушить прокси, а не регистр!

возвращать байтовый результат из функции в прокси?


если импортировать переменную (extern вместо var? и запрещено присваивание), то не надо создавать тело переменной, только запомнить тип
если импортировать константы (без присваивания), то не надо создавать тело константы, только запомнить тип
если константы будут как equ, то не надо создавать equ, только запомнить тип


автометки для строковых констант лучше делать локальными, а не глобальными
можно объявления автометок для строковых констант делать в LOCAL
но тогда при ассемблировании будет два одинаковых LOCAL
это не ошибка? уже есть при вызове функций

если не дублировать LOCAL в этом объявлении, то надо в fvar писать имя с префиксом, ПОТОМ (после затирания command) в fout писать имя без префикса
или:
1. генерируем имя в command (а не в joinwordsresult)
2. пишем в fout обращение к имени без префикса
 3. приклеиваем префикс из title+command (без точки в конце!!!) в joinwordsresult
 4. пишем в fvar имя с префиксом из joinwordsresult
5. читаем строку в кавычках в command
6. пишем command в fvar

проблемы со стрингами:

# command для переменных используется два раза (первый раз для определения типа) или даже три для LONG
без определения типа надо тип писать явно!
для LONG можно свалить работу на ассемблер:
_=blabla
ld hl,[_] ;emitgetreg (ещё используется с command и с автометкой)
ld de,[_+2] ;emitgetreg (ещё используется с command и с автометкой, то есть 4 варианта!)
можно сократить до 3 вариантов, если тут использовать ту же автометку и не сдвигать вложенность
или до 2 вариантов, если INT тоже делать через ту же автометку

# command для констант используется два раза (первый раз для определения типа по последней букве L) или даже три для LONG
вместо (кроме) буквы L можно префикс /*#*/ (префикс /*L*/ нельзя, т.к. есть регистр L)
для LONG можно см. выше
или можно константы передавать как числа (если реализовать функционал расчётов)

# нельзя использовать command в popvar, poppar, потому что до них идёт выражение или даже код, к тому же рекурсивно
т.е. надо рекурсивно сохранить кучу строк!
хранить имя рекурсивного локала в следующем локале нереально, т.к. тогда код не сможет найти следующий локал
сделать дополнительное поле в описателе метки для хранения предыдущей метки (если есть таблица меток)?
а как без таблицы меток? свалить работу на ассемблер:
_l2=_l1
_l1=_l0
_l0=blabla
ld hl,[_l0]
push hl
ld hl,...
ld [_l0],hl
...
pop hl
ld [_l0],hl
_l0=_l1
_l1=_l2
для этого надо poppar, popvar с параметром "l0"
и новые процедуры:
emit1equ2 для "_l1=_l0" и наоборот
emit1equcommand для "_l0=blabla"
и счётчик уровней вложенности, чтобы не генерировать лишние _l?

если есть счётчик, то проще так:
для параметров:
;сдвиг уровня вложенности (встроен в emittemplabelequ)
_ll..lll=blabla ;emittemplabelequ
ld hl,[_ll..lll] ;cemitpushvar -> emitgetreg (ещё используется при доступе к переменной в выражении, но там не автометка, а command!)
push hl
ld hl,...
ld [_ll..lll],hl ;cemitpopvar -> emitputreg (используется только так)
...
pop hl
ld [_ll..lll],hl ;cemitpoppar -> emitpopputfreereg (используется только так)
;возврат уровня вложенности (встроен в emittemplabelundef)

для рекурсивных локалов:
;сдвиг уровня вложенности (встроен в emittemplabelequ)
_ll..lll=blabla ;emittemplabelequ
ld hl,[_ll..lll] ;cemitpushvar -> emitgetreg (ещё используется при доступе к переменной в выражении, но там не автометка, а command!)
push hl
...
pop hl
ld [_ll..lll],hl ;cemitpoppar -> emitpopputfreereg (используется только так)
;возврат уровня вложенности (встроен в emittemplabelundef)

для переменных:
;сдвиг уровня вложенности (встроен в emittemplabelequ)
_ll..lll=blabla ;emittemplabelequ
...
ld [_ll..lll],hl ;cemitpopvar -> emitputreg
;возврат уровня вложенности (встроен в emittemplabelundef)

для чтения переменных:
;сдвиг уровня вложенности (встроен в emittemplabelequ)
_ll..lll=blabla ;emittemplabelequ
ld hl,[_ll..lll] ;cemitpushvar -> emitgetreg
;возврат уровня вложенности (встроен в emittemplabelundef)

это всё против переприсваивания и стекования

нужен LOCAL-ENDL, который добавляет уникальный идентификатор к своим внутренним меткам, которые начинаются с "@":

для while:

LOCAL ;генерирует уникальный_идентификатор
@TEMPWHILE: ;эквивалентно уникальный_идентификаторTEMPWHILE
 <условие>
 jp cc,@TEMPEND: ;эквивалентно уникальный_идентификаторTEMPEND
 <тело>
 jp @TEMPWHILE: ;эквивалентно уникальный_идентификаторTEMPWHILE
@TEMPEND: ;эквивалентно уникальный_идентификаторTEMPEND
ENDL
или локальные автонумерованные (в стеке запоминать номера)

для if:

<условие>
LOCAL ;генерирует уникальный_идентификатор
 jp cc,@TEMPELSE+3 ;эквивалентно уникальный_идентификаторTEMPELSE
 <тело then>
@TEMPELSE: ;эквивалентно уникальный_идентификаторTEMPELSE
 jp @TEMPENDIF ;эквивалентно уникальный_идентификаторTEMPENDIF
 <тело else>
@TEMPENDIF: ;эквивалентно уникальный_идентификаторTEMPENDIF
ENDL
или локальные автонумерованные (в стеке запоминать номера)

для call (там calltitle нужно сохранять в рекурсивном вызове, т.к. его может запороть вложенный call!):

LOCAL prefix
;_f=prefix
var=@blabla ;эквивалентно var=prefixblabla
LOCAL prefix2 ;старый идентификатор локалов сохраняется в стеке
;_ff=prefix2
var2=@blabla ;эквивалентно var2=prefix2blabla
call @ ;_ff
ENDL ;вспоминает старый идентификатор локалов
call @ ;_f
ENDL



если в if/while/until встретился == / != на верхнем уровне expression, то не делать вычисление флаговой переменной и or a (по fused)?
проблема в выражениях типа a == b == c, но они явно ошибочные (проверять?)

надо заменить &MYSTRING на MYSTRING, т.к. это уже указатель? как это будет выглядеть в nedolang? тоже массив==указатель?

//токенизировать только команду? в поле команды не может быть произвольная буква
//чтобы найти конец выражения, код команды не должен пересекаться с операциями и постфиксами (с префиксами можно)
//[код команды должен не пересекаться с буквами и цифрами (то есть доступно всего 128 кодов + префиксы + непечатные) с русскими можно? (они только в '', "" и комментариях) тогда нельзя русские имена меток]

что нужно сделать для самокомпиляции:

# константные массивы для размеров типов и названий регистров (можно заменить на функции или на заполнение массивов)
# forward определения функций или объявление функции также при использовании
если писать вызов /*@*/(type).name(/*par1=*/num1,/*par2=*/num2), то Си увидит (type).name(num1,num2)
если писать вызов /*@type.*/name(/*type par1=*/num1,/*type par2=*/num2), то Си увидит name(num1,num2)
вместо /*@*/ можно писать CALL, но не в выражении (т.к. может быть идентификатор CALL)
при вызове из выражения ожидается идентификатор или дефайн, как и в случае true/false
# include
# define (коды префиксов и регистров)
# таблица меток должна быть определена на массиве! или вообще её убрать (жёстко писать типы везде и чередовать cseg и dseg)


//чтобы детокенизатор и вывод текста был совсем простой, он должен находить команду независимо от числа параметров, т.е. коды команд должны не пересекаться с символами или иметь уникальный префикс



;чтобы прочитать новый буфер:
;dec remainsectors
;if (remainsectors != 0) {
 ;inc cursector
 ;read cursector
 ;if (remainsectors == 0) remain = lastlen&0xff
;}else {
 ;inc curblock
 ;if (curblock == blocks) {
  ;EOF
 ;}else {
  ;find new block descriptor
  ;set cursector
  ;lastlen = ?
  ;remainsectors = ?
 ;}
;}

;как вести себя при длине 0 при записи?

;чтобы сохранить текущий буфер и начать новый:
;get cursector
;save buf
;inc cursector
;if (cursector == freesector) {
 ;read sec8, inc freesector, dec freespace, write sec8
;}else {
 ;save file descriptor for old block
 ;cursector = freesector
 ;inc blocks, save file descriptor (len=lastlen), read sec8, inc files, write sec8
 ;(нельзя пропускать эти записи в начале создания файла, иначе другой файл может обновить эти данные неправильно)
 ;(можно пропустить, если дескриптор и секторы выделяется при flush!!!)
 ;lastlen=0
;}

компилятору надо раскрывать \t при компиляции строк!!!
это:
- asmstr ТОЛЬКО в do_asm
- emitvarstr_tword в emitvarstrz
компилятор всё делает правильно!
это ассемблер должен уметь так компилировать текст в кавычках!!!

readquotes сработало (dec c), идём на asmstr
asm выключен по умолчанию, правим стартап
все команды asm отработали
похоже не детектит //
or l
cpl
jp z
ошибка в emitinvb - надо fused=false
потом ошибка в fopen - b не равен 0
потом в flushdesc пропущен ld l,FCB.fn
потом в flush при выделении секторов номер сектора не записан в дескриптор (firstsector) и в cursector - пишем в 0-й

далее:
первый сектор ferr запорот fvar, первый сектор fasm запорот ferr (secwritten обнулялся не там, a!=0)

и лезет куча ошибок
все ld [],a, ld [],hl пустые
(автометки правильные)
пропущена ветка eat_variable.b (t = t|_T_ARRAY)
похоже, не может найти ни одну переменную
strcp (bb86), lbltype (8f29), addvar (8faf) выглядят правильно в fasm
c279 - lblbuf
неправильно скомпилировано       _lblbuf[_lblbufindex] = +(CHAR)(+(BYTE)len);
пишет a, который не присвоен:
	LD DE,[addvar.len.]
	LD [HL],A 
но после pokeb (где использовался до этого a) _rproxy = 0x00!!!
ошибка в emitpokeb - при (hl) писался всегда a.

fasm, ferr оборваны
неправильные размеры непервых блоков
не обнулялся lastlen

ассемблер валится на первом же токене
6cdb
потому что перед jp (hl) нет cmdpeek
исправил - теперь виснет на конце файла, т.е. не попал в case _ASMTOKEN_EOF: {goto endloop;/**exit!!!*/}
таблица switch вся заполнена default!!!
потому что генерируются метки asmloop.J0, а в таблице без J
но нельзя склеивать . с числом
исправил

теперь в конце сбрасывается
в org.f оказывается 44 байта вместо 4
5 ошибок в первой строке (комментарий 709a обработать не смог) и дальше ошибки в 2903 и далее (тоже комментарии)
начало bin.f совпадает, но длина #1656 вместо #160c
расхождение с #14a3 - лишние #c9 итп
это комментарий ";при чтении длина 0 - это отсутствие файлов или файл длиной 0 (длина в секторах может быть любая)"

UNTIL ((_token==+_ASMTOKEN_ENDCOMMENT)||_waseof)
скомпилилось в
	LD A,[_token.]
	LD E,_ASMTOKEN_ENDCOMMENT.
	SUB E
	LD L,0
	JR NZ,$+2+1
	DEC L
	LD A,[_waseof.]
	OR L
	JP C,asmloop.y 
потому что выше сравнение в параметре функции стояло без скобок и "оптимизировалось" на 1-м уровне вложенности выражения
исправил - всё скомпилилось правильно, но сбросилось

сделал защиту от "оптимизации" сравнений на первом уровне вложенности в присваиваниях и вызовах (начальный уровень вложенности там поставил выше)

в конце вываливается с ошибкой и портит бейсик, даже после одного прохода

вместо ex af,af' получается ex (sp),hl (токенизируется и экспортируется правильно)
коды sp и af совпадают - проверять надо второй регистр в ex
пофиксил - всё равно в конце вываливается с ошибкой
не присвоен hl'=10072!

ld (de),a неправильно ассемблировалось (токенизируется и экспортируется правильно)
reg вместо oldreg

;increase block number (after flushdesc!!!) ;глючит, если последний блок <256
ручной flush пока невозможен

0. начало работы (первое сохранение):
- создаём новый дескриптор
- сохраняем данные туда
- сохраняем дескриптор
- block++ (теперь дескриптор невалидный, пока не создадим новый)
1. добавляем много данных, пока блок не заполнится
2. блок заполнен:
- сохраняем дескриптор
- block++ (теперь дескриптор невалидный, пока не создадим новый)
3. добавляем немного данных
4. fclose:
- создаём новый дескриптор
- сохраняем данные туда
- сохраняем дескриптор (может быть с некруглой длиной)
- block++ (теперь дескриптор невалидный, пока не создадим новый)
(потом снова вызывается savedesc, но нам нельзя)
запретил вызов savedesc в fclose при 0 записанных секторов


сделал nedotrd, чтобы мог разрезать большие файлы по стандарту последовательных файлов TR-DOS (не через расширение, а через младший бит start), и чтобы 3-символьное расширение не попадало на диск
или придумать другой стандарт разрезания, чтобы не трогал ни расширение, ни start? разве что имя? или переключать второй символ расширения терпимо - поддержать в либе 3-символьное расширение?

сделал восстановление после RUN "" CODE (глюк в TR-DOS, описанный у Федина)
пофиксил DIVLONG
пофиксил MULLONG
;; не работал после строки, которая оканчивается на ; - сбросил waseols
исправил команду после метки в одной строке
добавил NEG
исправил _FMTCBCMDIDX
исправил I,R
исправил рекурсию в выражениях в токенизаторе
добавил проверку ) в if

FUNC BYTE lbltype() //вернуть тип метки joined
{
//формат записи:
//1 type
//1 lbllen
//N lbl (с 0)
////1 sizelen
////N size (с 0)
VAR UINT len;
VAR UINT i;
VAR UINT index;
VAR BYTE t;
VAR BYTE curt;
  t = _T_UNKNOWN;
  index = 0;
  i = 0;
  WHILE (i < _lblcount) {
    curt = +(BYTE)_lblbuf[index];
    INC index;
    len = +(UINT)(+(BYTE)_lblbuf[index]);
    INC index;
    IF (strcp(_joined/**, _lenjoined*/, /*+*/(PCHAR)(+(POINTER)_lblbuf + +(POINTER)index))) {
      t = curt;
      BREAK;
    };
    index = index + len + 1; //включая терминатор
//    len = (+(BYTE)_lblbuf[index]);
//    INC index;
//    index = index + len + 1; //включая терминатор
    INC i;
  };
#ifdef USE_HINTS
;;  hintstr("lbl="); hinttype(_joined, t);
#endif
  RETURN t;
}

PROC addvar(BYTE t/**, PCHAR size, UINT lensize*/) //joined
{
//формат записи:
//1 type
//1 lenlbl
//N lbl (с 0)
////1 lensize
////N size (с 0)
VAR UINT len;
VAR UINT i;
VAR BYTE oldt;
  oldt = lbltype(); //joined
  IF (oldt == _T_UNKNOWN) {
    IF ( _lblbufindex > (_LBLBUFLEN-_STRLEN-10) ) {
      errstr( "lbl buf overflow" ); enderr();
    }ELSE {
      _lblbuf[_lblbufindex] = +(CHAR)t;
      INC _lblbufindex;
      //добавить lenlbl и lbl
      len = _lenjoined;
      _lblbuf[_lblbufindex] = +(CHAR)(+(BYTE)len);
      INC _lblbufindex;
      i = _FIRST;
      WHILE (i < (len/**+_FIRST*/)) {
        _lblbuf[_lblbufindex] = _joined[i];
        INC _lblbufindex;
        INC i;
      };
      _lblbuf[_lblbufindex] = '\0'; //терминатор
      INC _lblbufindex;
      //добавить lensize и size
//      len = lensize;
//      _lblbuf[_lblbufindex] = +(CHAR)(+(BYTE)len);
//      INC _lblbufindex;
//      i = _FIRST;
//      WHILE (i < (len/**+_FIRST*/)) {
//        _lblbuf[_lblbufindex] = size[i];
//        INC _lblbufindex;
//        INC i;
//      };
//      _lblbuf[_lblbufindex] = '\0'; //терминатор
//      INC _lblbufindex;
      INC _lblcount;
    };
  }ELSE IF (oldt != t) {
    errstr("addvar type doesn't match previous declaration"); enderr();
  };
}







strjoin.
strjoin.d=$+1
        ld bc,0 ;from
strjoin.b=$+1
        ld hl,0 ;to
strjoin.c=$+1
        ld de,0 ;tolen
        add hl,de
;bc = from
;hl = to
;de = len
        ex de,hl
;bc = from
;de = to
;hl = len
strjoin.loop.
        ld a,l ;len
        cp _STRMAX.
        ret z ;jr z,strjoin.endloop.
        ld a,(bc) ;from
        or a
        ret z ;jr z,strjoin.endloop.
        ld (de),a ;to
        inc bc ;from
        inc de ;to
        inc l ;len
        jp strjoin.loop.


        
        
//пробелы и ентеры заменяет на _DIERESIS
PROC rdchall()
//добавляет cnext в tword
//и читает всю группу диерезисов + символ как один символ cnext
{
  //_lentword = stradd(_tword, _lentword, _cnext);
  IF (_lentword < _STRMAX) {
    _tword[_lentword/**+_FIRST*/] = _cnext;
    INC _lentword;
  };
  loop:
    _cnext = +(CHAR)readfin();
    IF (+(BYTE)_cnext < +(BYTE)'!') { //ускорение выхода
      IF (_cnext==' ') {
//        IF (!(_inprime||_indblquote)) {
          INC _spcsize; //spaces after tword
          //_wasdieresis = +TRUE;
          //IF (!_waseof) goto loop;
//        };
      }ELSE IF (_cnext == +(CHAR)0x0a) {
        //IF ( !_waseof ) {
          INC _curline;
          _spcsize = 0;
          //_waseol = +TRUE;
          INC _waseols;
        //}; //EOL after word (spcs may follow)
        //_wasdieresis = +TRUE;
        //IF (!_waseof) goto loop;
      }ELSE IF (_cnext == '\t') {
        _spcsize = _spcsize + 8; //TODO связать с X
        //_wasdieresis = +TRUE;
        //IF (!_waseof) goto loop;
//      }ELSE IF (_cnext == +(CHAR)0x0d) {
        //_wasdieresis = +TRUE;
        //IF (!_waseof) goto loop;
      };
      //_wasdieresis = +TRUE;
      IF (!_waseof) goto loop;
    };
//      }ELSE IF (_waseof) {
//        _wasdieresis = +TRUE;
  //читаем всю группу диерезисов + символ как один символ
}

        ;ld hl,10608 ;удаление буфера, если он есть

        
        сделать в стартапах чтение переменной бейсика a$ или первой попавшейся - как параметр
батники превратить в бейсики
автоматизировать вытаскивание батника из трдшника с батниками в рабочий трдшник

надо дать возможность указать start при записи на трдшник


command-line friendly в TR-DOS нельзя с кодовыми файлами - после CODE не получается ввести дополнительные параметры даже с разделителем , или : (вообще ни с каким), даже если указать 2 числовых параметра. единственный работающий разделитель - 0x0d, но его нельзя ввести с клавиатуры.
можно RUN "name    blablabla" CODE, но как отследить адрес дополнительного текста, особенно при вызове из бейсика?
сделал параметры в REM после RUN "name" CODE
там размер на пределе



как компилировать switch...case:
в выходном асме могут быть такие секции:
- СДЕЛАНО: список equ, отражающий enum: _NAMEDNUM1 = 1
- тела веток: procname.aab._NAMEDNUM1:код
? таблица, заполненная адресом default ветки: DUP 256:DW procname.aab.default:EDUP (или просто 256 раз)
? или же таблица, заполненная адресами: DW procname.aab._NAMEDNUM1
как её сформировать? правильный порядок следования есть только в enum
если известен enum, по которому switch, то можно эту таблицу заполнить по нему. но он в другом модуле, т.е. далеко. а в самом enum нельзя заполнить таблицу, т.к. enum может использоваться во многих switch.
- или же таблица, заполненная именами веток: DW procname.aab.1
для этого надо вывод числа в метку, можно в компиляторе (в do_switch)
- начальное заполнение имён веток: procname.aab.1 = procname.aab.default (чередуется с DW? или лучше до веток, а DW в самом конце, после всех веток)
для этого надо вывод числа в метку, можно в компиляторе (в do_switch)
- возможно список присваивания имён меток: procname.aab.1 = procname.aab._NAMEDNUM1 (чередуется с телами веток)
как его сформировать? для этого надо вычислить 1 из _NAMEDNUM1 (компилятор не может, т.к. enum в другом модуле)
для этого надо вывод числа в метку В АССЕМБЛЕРЕ
? или же патчи: PATCHW procname.aab.1,procname.aab._NAMEDNUM1 (нельзя будет просто грузить бинарник подряд)



чтобы было общее пространство имён переменных:
в метках компилятора лежат метки переменных без префиксов
при поиске метки не нужно добавлять префикс и точку в конце (они все были с точкой, кроме имён типов, теперь все будут без точки)
у них есть флаг (локальная/глобальная)
если локальная, то к ней в асме добавляется текущий префикс [и точка в конце]
в какой процедуре? или изначально в joined? а тип смотрим не по joined, а по tword?
сейчас lbltype есть в:
join_variable (надо без префикса - ГОТОВО)
//eatinc
//eatdec
do_callpar (для внешних меток параметров - там надо с префиксом - ГОТОВО)

join_variable есть в:
val (+_CONSTANT) (надо без префикса) перед cmdpushnum (надо без префикса - глобальное)
val (<var>) (надо без префикса) перед cmdpushvar/cmdpushnum/idxarray (надо с префиксом (локалы)/без префикса(глобалы))
val (&<var>) (надо без префикса) перед cmdpushnum/idxarray (надо с префиксом (локалы)/без префикса(глобалы))
eatlet (надо без префикса) перед cmdpoke/cmdpopvar (надо с префиксом (локалы)/без префикса(глобалы))
eatinc (надо без префикса) перед cmdinc (надо с префиксом (локалы)/без префикса(глобалы))
eatdec (надо без префикса) перед cmddec (надо с префиксом (локалы)/без префикса(глобалы))
do_call (надо без префикса? - чтобы узнать возвращаемый тип функции, потом joined копируется в callee - надо с префиксом)

addvar есть в:
eatextern (надо без префикса) перед varstr (надо с префиксом) - tword уже утерян (joined собран в eatvariable) - ГОТОВО
eatvar (надо без префикса) перед varstr (надо с префиксом) - tword уже утерян (joined собран в eatvariable) - ГОТОВО
eatvar (для внешней метки параметра - надо с префиксом) перед varstr (надо с префиксом) - tword уже утерян (joined собран вручную) - ГОТОВО
eatconst (надо без префикса) перед varstr (надо без префикса? или пока с префиксом) - tword уже утерян (joined собран в eatvariable) - ГОТОВО
eatfunc (надо без префикса?) перед cmdlabel (надо с префиксом?) - tword уже утерян (joined собран в join_title_tword_dot - используется ещё в eatlbl, eatgoto) - ГОТОВО
compile (инициализация таблицы меток - надо без префикса) - ГОТОВО

eatvariable не используется больше нигде, поэтому там надо сформировать _name - ГОТОВО

в eatvar (когда это par) проверка типа обламывается на PROC writebyte FORWARD(PBYTE file, BYTE c);
надо сделать addvar: name (если не forward) и title.autonum - ГОТОВО

можно ли использовать name в eattype?
eattype используется в:
- eatvariable - там можно
- val (*) - там можно?
- eatpoke - там можно
- eatfunc - там можно
- eatstruct - там можно


PROC tok_ex FORWARD();
PROC tok_ret FORWARD();
PROC tok_djnz FORWARD();
PROC tok_jr FORWARD();
PROC tok_jp FORWARD();
PROC tok_call FORWARD();
PROC tok_ld FORWARD();
PROC tok_add FORWARD();
PROC tok_adc FORWARD();
PROC tok_alucmd FORWARD(BYTE token);
PROC tok_sbc FORWARD();
PROC tok_inc FORWARD();
PROC tok_dec FORWARD();
PROC tok_rst FORWARD();
PROC tok_out FORWARD();
PROC tok_in FORWARD();
PROC tok_pop FORWARD();
PROC tok_push FORWARD();
PROC tok_cbxx FORWARD(BYTE token);
PROC tok_bit FORWARD(BYTE token);
PROC tok_im FORWARD();
PROC tokasm FORWARD();


PROC tokasm()
{
  IF (strcplow(_tword,"ld"  )) {tok_ld();

  }ELSE IF (strcplow(_tword,"call")) {tok_call();
  }ELSE IF (strcplow(_tword,"jp"  )) {tok_jp();
  }ELSE IF (strcplow(_tword,"ret" )) {tok_ret();
  }ELSE IF (strcplow(_tword,"jr"  )) {tok_jr();

  }ELSE IF (strcplow(_tword,"db"  )) {tok_db(); /**db ..., aianoi defb - iaai iinea ea?aiai au?a?aiey oi?iao writeN, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"dw"  )) {tok_dw(); /**dw ..., aianoi defw - iaai iinea ea?aiai au?a?aiey oi?iao writeNN*/
  }ELSE IF (strcplow(_tword,"dl"  )) {tok_dl(); /**dl ..., aianoi defl - iaai iinea ea?aiai au?a?aiey oi?iao writeNNNN*/
  }ELSE IF (strcplow(_tword,"ds"  )) {tok_ds(); /**ds ..., aianoi defs - iaai oi?iao writeds*/

  }ELSE IF (strcplow(_tword,"pop" )) {tok_pop();
  }ELSE IF (strcplow(_tword,"push")) {tok_push();

  }ELSE IF (strcplow(_tword,"add" )) {tok_add();
  }ELSE IF (strcplow(_tword,"adc" )) {tok_adc();
  }ELSE IF (strcplow(_tword,"sub" )) {tok_alucmd(+_ASMSUB);
  }ELSE IF (strcplow(_tword,"sbc" )) {tok_sbc();
  }ELSE IF (strcplow(_tword,"and" )) {tok_alucmd(+_ASMAND);
  }ELSE IF (strcplow(_tword,"xor" )) {tok_alucmd(+_ASMXOR);
  }ELSE IF (strcplow(_tword,"or"  )) {tok_alucmd(+_ASMOR);
  }ELSE IF (strcplow(_tword,"cp"  )) {tok_alucmd(+_ASMCP);

  }ELSE IF (strcplow(_tword,"inc" )) {tok_inc();
  }ELSE IF (strcplow(_tword,"dec" )) {tok_dec();

  }ELSE IF (strcplow(_tword,"ex"  )) {tok_ex();

  }ELSE IF (strcplow(_tword,"rlc" )) {tok_cbxx(+_ASMRLC);
  }ELSE IF (strcplow(_tword,"rrc" )) {tok_cbxx(+_ASMRRC);
  }ELSE IF (strcplow(_tword,"rl"  )) {tok_cbxx(+_ASMRL);
  }ELSE IF (strcplow(_tword,"rr"  )) {tok_cbxx(+_ASMRR);
  }ELSE IF (strcplow(_tword,"sla" )) {tok_cbxx(+_ASMSLA);
  }ELSE IF (strcplow(_tword,"sra" )) {tok_cbxx(+_ASMSRA);
  }ELSE IF (strcplow(_tword,"sli" )) {tok_cbxx(+_ASMSLI);
  }ELSE IF (strcplow(_tword,"srl" )) {tok_cbxx(+_ASMSRL);

  }ELSE IF (strcplow(_tword,"djnz")) {tok_djnz();

  }ELSE IF (strcplow(_tword,"rst" )) {tok_rst();

  }ELSE IF (strcplow(_tword,"out" )) {tok_out();
  }ELSE IF (strcplow(_tword,"in"  )) {tok_in();

  }ELSE IF (strcplow(_tword,"bit" )) {tok_bit(+_ASMBIT);
  }ELSE IF (strcplow(_tword,"res" )) {tok_bit(+_ASMRES);
  }ELSE IF (strcplow(_tword,"set" )) {tok_bit(+_ASMSET);

  }ELSE IF (strcplow(_tword,"im"  )) {tok_im();

  }ELSE IF (strcplow(_tword,"rlca")) {tok_xx(+_ASMRLCA);
  }ELSE IF (strcplow(_tword,"rrca")) {tok_xx(+_ASMRRCA);
  }ELSE IF (strcplow(_tword,"rla" )) {tok_xx(+_ASMRLA);
  }ELSE IF (strcplow(_tword,"rra" )) {tok_xx(+_ASMRRA);
  }ELSE IF (strcplow(_tword,"daa" )) {tok_xx(+_ASMDAA);
  }ELSE IF (strcplow(_tword,"cpl" )) {tok_xx(+_ASMCPL);
  }ELSE IF (strcplow(_tword,"scf" )) {tok_xx(+_ASMSCF);
  }ELSE IF (strcplow(_tword,"ccf" )) {tok_xx(+_ASMCCF);
  }ELSE IF (strcplow(_tword,"nop" )) {tok_xx(+_ASMNOP);
  }ELSE IF (strcplow(_tword,"halt")) {tok_xx(+_ASMHALT);
  }ELSE IF (strcplow(_tword,"di"  )) {tok_xx(+_ASMDI);
  }ELSE IF (strcplow(_tword,"ei"  )) {tok_xx(+_ASMEI);
  }ELSE IF (strcplow(_tword,"exx" )) {tok_xx(+_ASMEXX);

  }ELSE IF (strcplow(_tword,"retn")) {tok_xx(+_ASMRETN);
  }ELSE IF (strcplow(_tword,"reti")) {tok_xx(+_ASMRETI);
  }ELSE IF (strcplow(_tword,"ldi" )) {tok_xx(+_ASMLDI);
  }ELSE IF (strcplow(_tword,"ldd" )) {tok_xx(+_ASMLDD);
  }ELSE IF (strcplow(_tword,"ldir")) {tok_xx(+_ASMLDIR);
  }ELSE IF (strcplow(_tword,"lddr")) {tok_xx(+_ASMLDDR);
  }ELSE IF (strcplow(_tword,"cpi" )) {tok_xx(+_ASMCPI);
  }ELSE IF (strcplow(_tword,"cpd" )) {tok_xx(+_ASMCPD);
  }ELSE IF (strcplow(_tword,"cpir")) {tok_xx(+_ASMCPIR);
  }ELSE IF (strcplow(_tword,"cpdr")) {tok_xx(+_ASMCPDR);
  }ELSE IF (strcplow(_tword,"ini" )) {tok_xx(+_ASMINI);
  }ELSE IF (strcplow(_tword,"ind" )) {tok_xx(+_ASMIND);
  }ELSE IF (strcplow(_tword,"inir")) {tok_xx(+_ASMINIR);
  }ELSE IF (strcplow(_tword,"indr")) {tok_xx(+_ASMINDR);
  }ELSE IF (strcplow(_tword,"outi")) {tok_xx(+_ASMOUTI);
  }ELSE IF (strcplow(_tword,"outd")) {tok_xx(+_ASMOUTD);
  }ELSE IF (strcplow(_tword,"otir")) {tok_xx(+_ASMOTIR);
  }ELSE IF (strcplow(_tword,"otdr")) {tok_xx(+_ASMOTDR);
  }ELSE IF (strcplow(_tword,"inf" )) {tok_xx(+_ASMINF);
  }ELSE IF (strcplow(_tword,"neg" )) {tok_xx(+_ASMNEG);

  }ELSE IF (strcplow(_tword,"org" )) {tok_org(); /**org nn - iaai oi?iao writeorg, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"align")){tok_align(); /**align nn - iaai oi?iao writealign, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"page")) {tok_page(); /**page n - iaai oi?iao writepage, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"if"  )) {tok_if(); /**if nn - iaai oi?iao writeif, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"else")) {tok_else(); /**else*/
  }ELSE IF (strcplow(_tword,"endif")){tok_endif(); /**endif*/
  }ELSE IF (strcplow(_tword,"dup" )) {tok_dup(); /**dup nn - iaai oi?iao writedup, ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiey*/
  }ELSE IF (strcplow(_tword,"edup")) {tok_edup(); /**edup*/
  }ELSE IF (strcplow(_tword,"macro")){tok_macro(); /**macro name - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"endm")) {tok_endm(); /**endm*/
  }ELSE IF (strcplow(_tword,"usemacro")){tok_usemacro(); /**usemacro name ... - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"local")){tok_local(); /**local name - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"endl")) {tok_endl(); /**endl*/
  }ELSE IF (strcplow(_tword,"disp")) {tok_disp(); /**disp nn - iaai oi?iao writedisp*/
  }ELSE IF (strcplow(_tword,"ent" )) {tok_ent(); /**ent*/
  }ELSE IF (strcplow(_tword,"include")){tok_include(); /**include "filename" - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"incbin")){tok_incbin(); /**incbin "filename" - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"display")){tok_display(); /**display nn - oi?iaou displaynum, displaystring - ?acae?aou a?o?io? ia iieo?eony ec-ca au?a?aiee*/
  }ELSE IF (strcplow(_tword,"repeat")){tok_repeat(); /**repeat*/
  }ELSE IF (strcplow(_tword,"until")){tok_until(); /**until nn - iaai oi?iao writeuntil*/
  }ELSE IF (strcplow(_tword,"struct")){tok_struct(); /**struct name - ?acae?aou a?o?io??*/
  }ELSE IF (strcplow(_tword,"endstruct")){tok_endstruct(); /**endstruct*/

  }ELSE tok_err(+_ERRCMD); //wrong _tword
};


  l:
  IF (_lentword < _STRMAX) { //в асме из компилятора все слова короче, но не в ручном асме
    _tword[_lentword] = _cnext;
    INC _lentword;
  };
  IF (_isalphanum[+(BYTE)_cnext] ) { //слово с цифробуквы (обход, если слово из нецифробуквы (добавлено) или нецифробуква в слове (TODO не добавлена!)
    _cnext = +(CHAR)readfin();
    goto l;
  };
  _cnext = +(CHAR)readfin();

  
  если в ассемблере система меток такая же, как в языке:
label
.leveluplabel
localblock.label
а как тогда получить название текущего блока (нужно для call)?
можно сгенерировать метку proc.start. (но тогда нельзя переменную start.)
или proc.start (tempelse и т.п. тоже без точек справа, чтобы не накладывать на переменные)

надо иметь два дерева локалов: для генерации меток и для доступа по @?

вызов:
# путь доступа = текущий путь+имя процедуры
# читаем имя переменной
# parlabel = "путь доступа+имя переменной" (@par)
# сохраняем из переменной "путь доступа+имя переменной" (@par)
# вычисляем выражение в текущем пути
# poke в parlabel
...
# вызываем путь доступа (@)
...
# вспоминаем
# poke в parlabel
# можно закрыть блок пути доступа
но при вложенном вызове путь доступа потеряется! в начале блока надо его сохранять, в конце восстанавливать!
или использовать строковые "переменные" внутри ассемблера, которые можно склеивать и превращать в метки

или:
# calllabel = текущий путь+имя процедуры
# читаем имя переменной
# parlabel = текущий путь+имя процедуры+имя переменной (как помнить имя процедуры? писать его в каждом параметре?)
# сохраняем [parlabel]
# вычисляем выражение в текущем пути
# poke в parlabel
...
# вызываем calllabel
...
# вспоминаем
# poke в parlabel
# можно закрыть блок


strcplow
strcplow.A.=$+1
	ld de,0 ;s1
strcplow.B.=$+1
	ld hl,0 ;s2
	ld c,0x20
strcplow0.
	ld a,[de] ;s1
	or c;0x20
	sub [hl] ;s2
	inc hl
	inc de
	jp z,strcplow0.
;strcplowbad.
	sub c;0x20
	cpl
	ret z ;0xff = TRUE ;раньше не совпало, а теперь совпало - '\0' (т.к. заглавных нет в s2)
	xor a ;FALSE
	ret
;strcplowgood.
;	cpl ;TRUE
;	ret

readfinstr
	ld hl,0 ;len
readfinstr.A.=$+1
	ld bc,0 ;s
readfinstr0.
        push hl
        call readfin
        pop hl
        cp 0x0d
        jr z,readfinstr0. ;skip 0x0d
        cp '\n'
        jr z,readfinstrq. ;EOL or EOF
        ld [bc],a
        inc bc
	inc l;hl ;len
	ld a,l
	cp _STRMAX
	jp c,readfinstr0.
readfinstrq.
        xor a
        ld [bc],a
        inc l;hl ;len
        ret ;hl=len


compiled by IAR (typedef unsigned int intptr_t, странички по 4 байта вместо 0x4000):
..\z80\bin\iccz80 -v0 -ml -uua -q -e -K -gA -s9 -t4 -T -Llist\ -Alist\ -I"../z80/inc/" mainasm.c
(стартапа в коде нет)
Code size: 7283
Constant size: 656
Static variable size: Data(523) Iram(0)
итого 8462


как сделать размер массива объявленной константой? константы генерятся с точкой
как вычислить одну константу из другой? даже если поддержать вычитывание скобок, то константы генерятся с точкой
проще сделать #define без параметров? но тогда надо сделать в readconcattword (или только readtword?) чтение из буферной строки вместо файла
если переставить точки с неточками, то будет пересекаться с метками в либе (хотя можно их тоже с точками), с метками свитча (а как к ним приклеить точку???), ещё надо переделать приклейку-отклейку неймспейсов
ещё и два раза писать константу - в #define и в const!!
проще реализовать #define на уровне лексера


как сделать массив строк? как массив указателей
что делать с этим:
  static CHAR REGNAME[6][3] = { "??", "HL", "DE", "BC", "AF", "HL" };
???
по идее надо в константах поддержать строковые константы. Такое уже работает: CONST PCHAR pcpc = "abc";
можно без многомерных массивов так:
  static PCHAR REGNAME[6] = { "??", "HL", "DE", "BC", "AF", "HL" };
но тогда надо одновременно генерить массив и строки
(добавить ещё один файл?)
но такая же одновременность нужна при заполнении многомерного массива или массива структур или структуры с подструктурой!!!


ассемблер может быть с процедурами, оптимизацией, макросами, локалами, автометками и т.п. или вообще без всего, даже может быть из токенизированного текста с разжёванными выражениями и метками фиксированной длины, или вообще без ассемблера

stringconstkiller
а)
NedoPre
NedoLang+asmtokenizer (NedoLang выдаёт токенизированный ассемблер, asmtokenizer - токенизатор для асм-вставок)
asmcompiler (читает токенизированный ассемблер, выдаёт бинарник + таблицу блоков org? + таблицу экспортируемых меток?)
б)
gcc

для самокомпиляции NedoLang можно тоже использовать stringconst killer (например, чтобы получить строки с длиной, удалить одинаковые и сделать локализацию)
NedoLang можно использовать и в качестве макроассемблера (особенно хорошо было бы с оптимизацией функций - выкидывание неиспользованных и раскидывание по страницам через сгенерированные thunk'и)

можно склеивать асм через стартап-сорец, тогда в нём надо ссылаться на токенизированные файлы
значит, каждый асм надо токенизировать отдельно - будет проблема с одноимёнными asm/var (вызывать токенизатор группами файлов?)
[- или как вариант - обслуживать include в токенизаторе??? заодно можно там же ифы и макросы, так будет полноценный препроцессор (но тогда нельзя ифы по чтению из памяти, сложно по значению метки) - вариант не годится для редактирования токенизированного асма]


надо sdk и либы в каталоге ../_sdk/ (будет фигурировать в include, в path, в параметрах токенизатора(ассемблера?))
а временные файлы в tmp/ (туда должен класть компилятор, токенизатор, ассемблер, фигурирует в параметрах nedotrd)
как заставить компилятор, токенизатор, ассемблер класть в tmp/ по умолчанию - они будут создавать каталог? или задокументировать обязательность каталога tmp?
или сделать общий ../_sdk/tmp/, откуда можно копировать по желанию? а кто его будет чистить перед всей компиляцией?


в идеале батник должен быть такой:
nedolang emit.c read.c commands.c compile.c //сам выводит ошибки в stdout (без скролла?!)
nedotok emit.asm emit.var commands.asm commands.var lib.i io.i str.i //сам выводит ошибки в stdout
nedotok comp.s compcode.s read.asm read.var compile.asm compile.var //сам выводит ошибки в stdout
nedoasm compcode.S_ //делает compcode.bin compcode.D_ //сам выводит ошибки в stdout
nedoasm comp.S_ //делает comp //сам выводит ошибки в stdout

run.bat (несовместимый):
path ..\_sdk\ //несовместимо, если не написать утилиту для *nix
compile.bat
set output=comp.trd
nedotrd %output% -n
nedotrd %output% -ah ..\_sdk\boot.$b
nedotrd %output% -ac ..\_sdk\cmd
nedotrd %output% -a compile.bat
nedotrd %output% -ac comp
nedotrd %output% -ac ..\tok\tok
nedotrd %output% -ac ..\asm\asm
nedotrd %output% -a str.h
nedotrd %output% -a io.h
nedotrd %output% -a sizestg.h
nedotrd %output% -a emit.h
nedotrd %output% -a emit.c
nedotrd %output% -a read.c
nedotrd %output% -a typecode.h
nedotrd %output% -a regs.c
nedotrd %output% -a codetg.c
nedotrd %output% -a commands.c
nedotrd %output% -a compile.c
nedotrd %output% -a compcode.s
nedotrd %output% -a comp.s
nedotrd %output% -a lib.i
nedotrd %output% -a str.i
nedotrd %output% -a io.i
emul %output%


	
      }ELSE IF (_t == (_T_STRUCT|_T_POI)) { //&<pstruct>-><field>
        cmdpushvar(); //указатель на структуру
        rdword(); //'-'
        rdword(); //'>'
        rdword(); //field
        adddots();
        _t = joinvarname(/**iscall*/+FALSE);
        cmdpushnum();

метки tok 25799
теперь tok отдельным проектом и может пересекаться по меткам с компилятором
урежем метки
стало 24507


;можно в цикле ((trsec | 0x00f0) + 0x0001) & 0xff0f
;

# СДЕЛАНО: автозаменить _tword[_FIRST] на *(PCHAR)_tword

# СДЕЛАНО: в eat_cmd сделать на первом уровне проверку только одного символа (объём буфера под метки не меняется)

# СДЕЛАНО: убрать REGANAME

# СДЕЛАНО: убрать из таблицы меток длину массива (теперь нельзя сгенерить метки в конце (но там и строковое содержимое не хранилось))

# СДЕЛАНО: глобальные _rnew, _rold

# СДЕЛАНО: экранировать hints и comments через ;; (в IAR нельзя экранировать PROC, в билдере можно)

# СДЕЛАНО: заменить 8 пробелов на табы

# СДЕЛАНО: getmain4regs использует регистры в том же порядке, как они заполнены через ld (если совпадают)

# СДЕЛАНО: заменить (invztob) только для байтов!!!
        LD A,'e'
        SUB L
        LD L,0
        JR Z,$+2+1
        DEC L 
для != (invztob) на
        LD A,'e'
        SUB L
        JR Z,$+2+2
        LD A,0xff
а для == (ztob) на
	ld a,(varname)
	sub N
	sub 1
	sbc a,a

# inc/dec (очень много вариантов кода, для начала можно get8/16...inc8/16...put8/16)
СДЕЛАНО 8/16
inc var (BYTE):
ld hl,var
inc (hl)

inc var (UINT):
ld hl,var
inc (hl)
jr nz,$+2+1+1
inc hl
inc (hl)
;обычно 32 (быстрее, чем ld hl,():inc hl:ld (),hl =38)

inc *(PBYTE)(poi):
ld hl,(poi)
inc (hl)

inc *(PUINT)(poi):
ld hl,(poi)
inc (hl)
jr nz,$+2+1+1
inc hl
inc (hl)

dec var (BYTE):
ld hl,(var)
dec hl

dec var (UINT):
ld hl,(var)
dec hl
ld (var),hl
;38

dec *(PBYTE)(poi):
ld hl,poi
dec (hl)

dec *(PUINT)(poi):
ld hl,poi
inc (hl)
dec (hl)
jr nz,$+2+1+1
dec (hl)
inc hl
dec (hl)
;обычно 52
или
ld hl,poi
ld a,(hl)
or a
jr nz,$+2+1+1
dec (hl)
inc hl
dec (hl)
;обычно 46
;плохо при совмещении байтового и регистрового контекстов (unproxy+proxy займёт 8 тактов или больше для lx)

# СДЕЛАНО: это можно оптимизировать через подпрограммы:
emitasm_const( _REGNAME[+(UINT)rveryold] );
ещё можно загнать в подпрограммы повторяющиеся команды


для отладки арм таргета надо им компилировать известные файлы для Z80 и смотреть известный результат
тогда не надо del, move
но надо diff

тогда токенизатор должен создавать файлы .A_, .V_, .I_, .S_, в зависимости от типа (вторая буква нужна для FAT)
в include можно писать оригинальное название? СДЕЛАНО

нужен командный процессор
желательно, чтобы формат батника совпадал с мсдос/юникс
т.е. вызовы без расширений + имена файлов без ключей, и больше ничего
при работе командного процессора можно хранить только резидент и открытый файл батника, остальное каждый раз подгружать
в .bat уже нельзя будет call comp.bat - надо делать отдельные экзешники comp, tok, asm - СДЕЛАНО
билдер не позволяет назвать проект asm, поэтому команды будут nedolang, nedotok, nedoasm

как компилировать во временной папке? и даже чтобы исходники были разбросаны по каталогам?
в мсдос и юникс разные слеши, тогда батники будут несовместимы!!!
в си разрешены прямые слеши в #include, т.е. мы тоже возьмём прямые


