//пытаемся решить одновременно следующие задачи:
//- все токены (кроме text) без параметров, для простой печати
//- быстрая компиляция частых команд
//- разбор вручную - это плохо, т.к. выражение - набор токенов, да и вместо регистра может быть метка регистра (или параметр макроса?)
//значит, надо в середине и конце команды ставить токены-подсказки и формат
//(если токенизировать команду после прохождения всех условий, то как тогда стримить выражение?)
//на все директивы компилятора можно один формат (каждая директива запоминает свой код)
//- по идее в каждой группе надо максимум 2 формата команды (чтобы на токене команды загрузить 2 регистра базами, а потом применить один из них),
//но для уникальных форматов можно хранить опкод в закрывающем токене-формате
//- проверка ошибок подстановки регистров в токенизаторе (в компиляторе только ошибки disp?)
//- для удобства макросов и подмены регистров надо b/c/d/e/h/l/a/hx/lx/hy/ly взаимозаменяемые. Но нет команд типа ld lx,h, ld lx,ly, ld lx,(hl), ld lx,(ix+).
//Надо сделать проверку в конце команды, заодно там формировать префикс (иначе получится два префикса в ld hx,lx).
//- bc/de/hl/sp/ix/iy (в том числе в скобках) заменяемы везде, кроме ld a,(bc/de/hl/ix/iy) (там есть ручная проверка), ld (bc/de/hl/ix/iy),a (там есть ручная проверка).
//нельзя подменять rp на af (хотя push af - тот же формат, что push rp, код af==код sp).
//Есть ещё много команд, где rp фиксирована, поэтому токенизатор должен выдавать ошибку при попытке такой подмены.
//ix может встретиться в команде два раза: add ix,ix, а add ix,iy должно вызывать ошибку (хотя второй параметр подменяемый!),
//поэтому надо уже в формате проверять ix вручную и писать префикс.
//- минимизация числа токенов (команды + регистры + форматы...)
//- только один формат регистра
//(отдельный токен добавления регистра в команду? на рисках три поля регистров, так что надо ещё токен(ы) сдвига)
//(на рисках можно и в тексте работать (но тогда не универсально))
//поэтому пусть comma двигает регистры reg->oldreg->veryoldreg
//- по возможности не раздувать число токенов в строке (скорость и размер текста)

//все команды, регистры, условия могут быть только маленькими буквами, иначе надо второй набор токенов (кроме форматов и обрывов)

//типичная строка:
//<label><text>метка<endtext>
//<inc><HL><asmfmt_incrp>
//<comment><text>текст<endtext>
//<eol>

//ASMCMD...TOK...FMT для нормальных команд
//TOK_ERR,TOK_TEXT для неправильной мнемоники (или придумать CMD_ERR, чтобы было CMD...FMT?)
//ASMCMD...TOK_ERR,TOK_TEXT...FMT_ERR для неправильных параметров (чтобы тоже было CMD...FMT на всякий случай)

CONST BYTE _ASMMAXSPC = 0x08;

//#define TOKBASE 0x40
//#define ASMCCBASE    0x01 /*max 0x07*/
//#define TOKBASE 0x10 /*max 0x0b*/
//#define ASMOPBASE    0x1c /*max 0x02*/
//#define ASMREGBASE   0x66 /*max 0x15*/ /*не затереть []^*/
//#define DIRBASE   0x60 /*max 0x1c*/ /*не затереть |~*/
//#define OPBASE 0x7f /*max 0x10*/
//#define ASMCMDBASE   0x90 /*max 0x41*/
//#define FMTBASE   0xd2 /*max 0x2a*/

#ifdef TARGET_THUMB
#include "../_sdk/fmtarm.h"
#else
#include "../_sdk/fmtz80.h"
#endif

/**ошибка <TOK_ERR><TOK_ERR...>, после неё блоки <text>text<endtext><space><text>text<endtext>... <enderr> - чтобы выводить ошибки токенизатора вместе с ошибками компиляции*/
CONST BYTE _ERRCMD = 0x31;
//#define _ERRCMD   '1' /*(TOKBASE+0x02)*/
CONST BYTE _ERREXPR = 0x32;
//#define _ERREXPR  '2' /*(TOKBASE+0x03)*/
CONST BYTE _ERRCOMMA = 0x33;
//#define _ERRCOMMA '3' /*(TOKBASE+0x04)*/
CONST BYTE _ERRPAR = 0x34;
//#define _ERRPAR   '4' /*(TOKBASE+0x05)*/
CONST BYTE _ERROPEN = 0x35;
//#define _ERROPEN  '5' /*(TOKBASE+0x06)*/
CONST BYTE _ERRCLOSE = 0x36;
//#define _ERRCLOSE '6' /*(TOKBASE+0x07)*/
CONST BYTE _ERRREG = 0x37;
//#define _ERRREG   '7' /*(TOKBASE+0x08)*/

