для файлов с переменными можно сгенерить include в каждом
но надо знать модель памяти (вдруг надо разделить команды и данные!)

#include "name.h"
должен выдавать:
include "name.dec"
incobj "name.bin","name.rel" или просто incobj "name"
это может быть любое место исходника (в стартапе инклюды в конце)
что если заголовочный файл включает другой заголовочный файл? ничего страшного, как будто подряд?

как использовать один и тот же заголовочный файл для объявлений и использования? в gcc так нельзя?
extern!=export (в си нет export)

как передавать нумерацию модулей для обращений в объектнике?
можно ли относительный номер перенумеровать в глобальный? (один и тот же модуль может быть включен в разные!!!)
номер можно назначать по порядку компиляции (даже если перекомпилировать неизменённый не надо)
надо перекомпилировать неизменённый модуль, если он использует изменённый модуль!!! (это потому что он привязывается к смещениям в декларациях используемого модуля)
даже если привязываться не к смещениям, а к номерам символов, то вставка функции потребует перекомпилировать все модули, которые используют его
можно от первого изменившегося перекомпилировать все последующие модули
ещё надо перекомпилировать всё при изменении структуры связей модулей

если это не сделать, то в линкере надо работать с символьными метками, то есть линкер не может стать лоадером (нужна память под метки)

какой символ сделать для деклараций типа metka=<symbol><номермодуля>+<смещение>?
или другой формат деклараций?

ассемблерный файл должен знать свой номер модуля, чтобы правильно выгружать декларации!
не страшно, если у ассемблера будет тот же список файлов, что у компилятора?
или список файлов компилятора ни на что не влияет?




не следует объединять .asm и .var в один файл (т.к. их надо компилировать в разные пространства)
а инициализированные переменные - ещё одно пространство? сейчас явных нет, но есть константные массивы и структуры


можно сделать утилиту очистки временных файлов - для всех трёх осей разную








ускорение сборки:
а) упростить компилятор
б1) ускорить токенизатор
б2) убрать токенизатор
в) сделать однопроходный асм?
г) улучшить кодогенерацию? не факт, что это ускорит сборку
д) убрать специфические процедуры в стартап асмом (например, rdtword, genautonum)
е) добавить REGISTER
ё) токенизировать недоланг (ключевые слова и двойные символы)
ж) генерировать обж прямо из недоланга (с патчами)(тогда нельзя асмовставки и асмопроцедуры - только асмомодули), сделать специальный линкер или лоадер







построение проекта:
в ассемблер попадает больше файлов, чем в компилятор, т.к. добавляются ещё стандартные процедуры умножения-деления и файлы с переменными
или в ассемблер попадёт всего два файла - склеенный код (с приклеиванием стандартных процедур) и склеенные переменные, или только один склеенный код


если просто вклеить токенизатор в компилятор, то он будет слишком жирным (особенно по меткам)
можно убрать инлайн ассемблер и заставлять инклюдить токенизированные ассемблерные файлы
тогда компилятор просто будет выводить токенизированный асм вместо текста

reader будет общий у компилятора и токенизатора (и поддерживает комменты)
тогда reader должен писать коммент в нетокенизированный ассемблерный текст и в токенизированный одинаково
или нетокенизированный ассемблерный текст не существует
тогда комментарии/ошибки тоже должны об этом знать! токенизировать комментарии/ошибки на уровне emitter?
(компилятор может не выводить ошибки в ferr, а выводить прямо в асм)








типность можно убрать в _istype (обнулять при старте и после тайпкаста)

раньше не было зарезервированных слов
сейчас зарезервированы слова:
- default (можно разрезервировать, но тогда 1. нельзя получить указатель на метку (в gcc особая команда &&labelname?), [2. пользовательские метки пересекутся с автометками (но можно добавить не одну точку, а две)])
- TRUE, FALSE (если будет include, то можно определить, но сам тип BOOL лучше не определять - он нужен в if, while, repeat)
- имена базовых типов - а они не соответствуют зарезервированным сишным именам!
(ассемблерные команды вроде как не зарезервированы, т.к. имя метки проверяется в начале строки)


чтобы заполнить константную структуру, надо где-то взять список полей
или каждое поле будет выделяться по размеру написанного там значения (чревато багами)
зато можно объединить с массивом
но сейчас нельзя определить ширину типа по tword - она определяется по типу массива


todo:
в структуре поле типа массив
переделать &arr[] в &(arr[]) для упрощения?


;для такого (call...=...define) не хватает двух проходов, и ошибка не пишется
closewrite=fclosewrite
closewrite.A.=fclosewrite.A.
	EXPORT closewrite
	EXPORT closewrite.A.
...
EXPORT PROC fclosewrite(PBYTE file)
{
  fclose(file);
}


в асме добавить LIMIT addr, при достижении этого адреса выводить ошибку limit

todo проверить знаковое сравнение

todo проверить в токенизаторе, ставится ли LF перед ошибкой в начале строки (при отладке Thumb вылезло)

в Си помечаются не int, а uint (1U)

в Си помечается не export, а локальность (const - для функций, по крайней мере)

указатели FAR, NEAR, HUGE - где взять образцы исходников в таком стиле?

в Си limits.h содержит INT_MAX, CHAR_BIT итп


a >> n, a << n, p + n (в Си) - не алгебраические операции, т.к. их операнды разного типа
-a (в NedoLang), p - p (в Си), сравнения - не алгебраические операции, т.к. их результат другого типа


todo выравнивание полей структуры

